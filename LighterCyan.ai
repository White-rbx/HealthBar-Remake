-- string starting//
-- string:LighterCyan:ai(1)
-- Parent Finder
local Ex = game:GetService("CoreGui").TopBarApp.TopBarApp.UnibarLeftFrame.HealthBar.ExperienceSettings
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--[[
Error, Warn and Information Detectors
~~~~~~~~~~~~~~~~~~
Error: 0
Warn: 0
Information: 0
~~~~~~~~~~~~~~~~~~
Script state: Good
~~~~~~~~~~~~~~~~~~
]]

-- ====FUNCTION CORNER=====
local function Corner(Scale, Offset, Parent)
  local Corner = Instance.new("UICorner")
  Corner.CornerRadius = UDim.new(Scale or 0, Offset or 0)
  Corner.Parent = Parent
  return Corner
end
-- =====END FUNCTION CORNER====

-- =====FUNCTION UILISTLAYOUT=====
local HCenter = Enum.HorizontalAlignment.Center
local VCenter = Enum.VerticalAlignment.Center
local HLeft = Enum.HorizontalAlignment.Left
local VTop = Enum.VerticalAlignment.Top
local HRight = Enum.HorizontalAlignment.Right
local VBottom = Enum.VerticalAlignment.Bottom
local FillH = Enum.FillDirection.Horizontal
local FillV = Enum.FillDirection.Vertical
local SCustom = Enum.SortOrder.Custom
local SLayout = Enum.SortOrder.LayoutOrder
local SName = Enum.SortOrder.Name

local function createUIListLayout(parent, scale, offset, HZ, VT, SO, FILL)
    local list = Instance.new("UIListLayout")
    list.Padding = UDim.new(scale or 0, offset or 0)
    list.FillDirection = FILL or FillH
    list.HorizontalAlignment = HZ or HCenter
    list.VerticalAlignment = VT or VCenter
    list.SortOrder = SO or SName
    list.Parent = parent
    return list
end
-- =====END FUNCTION UILISTLAYOUT=====

-- ====FUNCTION UISTROKE=====
local ASMBorder = Enum.ApplyStrokeMode.Border
local ASMContextual = Enum.ApplyStrokeMode.Contextual

local LJMBevel = Enum.LineJoinMode.Bevel
local LJMMiter = Enum.LineJoinMode.Miter
local LJMRound = Enum.LineJoinMode.Round

local function Stroke(parent, ASM, R, G, B, LJM, Tn, Transy)
    local stroke = parent:FindFirstChildOfClass("UIStroke") or Instance.new("UIStroke")
    stroke.ApplyStrokeMode = ASM or ASMBorder
    stroke.Color = Color3.fromRGB(R or 255, G or 255, B or 255)
    stroke.LineJoinMode = LJM or LJMRound
    stroke.Thickness = Tn or 1
    stroke.Transparency = Transy or 0
    stroke.Parent = parent
    return stroke
end
-- =====END FUNCTION UISTROKE=====

-- ====FUNCTION UIGRADIENT=====
local function Gradient(parent, rotation, offsetX, offsetY, ...)
    local grad = parent:FindFirstChildOfClass("UIGradient") or Instance.new("UIGradient")
    grad.Rotation = rotation or 0
    grad.Offset = Vector2.new(offsetX or 0, offsetY or 0)

    local colors = {...}
    local keypoints = {}

    if #colors == 0 then
        keypoints = { ColorSequenceKeypoint.new(0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1, Color3.new(1,1,1)) }
    elseif #colors == 1 then
        keypoints = { ColorSequenceKeypoint.new(0, colors[1]), ColorSequenceKeypoint.new(1, colors[1]) }
    else
        for i, c in ipairs(colors) do
            local t = (i-1) / (#colors-1)
            table.insert(keypoints, ColorSequenceKeypoint.new(t, c))
        end
    end

    grad.Color = ColorSequence.new(keypoints)
    grad.Parent = parent
    return grad
end
-- =====END FUNCTION UIGRADIENT=====

-- ====FUNCTION UIPADDING (ตามลำดับ Roblox)=====
local function Padding(parent, bottom, left, right, top)
    local pad = parent:FindFirstChildOfClass("UIPadding") or Instance.new("UIPadding")
    local function toUDim(value)
        if typeof(value) == "UDim" then
            return value
        elseif type(value) == "number" then
            return UDim.new(0, value)
        elseif type(value) == "table" and #value >= 2 then
            return UDim.new(value[1] or 0, value[2] or 0)
        else
            return UDim.new(0, 0)
        end
    end

    pad.PaddingBottom = toUDim(bottom)
    pad.PaddingLeft   = toUDim(left)
    pad.PaddingRight  = toUDim(right)
    pad.PaddingTop    = toUDim(top)

    pad.Parent = parent
    return pad
end
-- =====END FUNCTION UIPADDING==end

-- Instance
local Gui = Instance.new("ScreenGui")
Gui.Name = "LighterCyan.ai"
Gui.ResetOnSpawn = false
Gui.Parent = Ex -- Ex คือ PlayerGui ในสคริปต์นี้
createUIListLayout(Gui, 0, 5, HCenter, VBottom, SName, FillV)

local useless = Instance.new("Frame")
useless.Name = "Holder"
useless.Size = UDim2.new(0.5, 0, 0.9, 0)
useless.BackgroundTransparency = 1 -- แก้จาก .Transparency
useless.Active = false
useless.Parent = Gui
createUIListLayout(useless, 0, 5, HCenter, VCenter, SName, FillV)

local insetFrame = Instance.new("Frame")
insetFrame.Name = "InsetFrame"
insetFrame.Size = UDim2.new(0.96, 0, 1, 0)
insetFrame.BackgroundTransparency = 1
insetFrame.Parent = useless
createUIListLayout(insetFrame, 0, 5, HCenter, VBottom, SName, FillV)

-- [ INSETFRAME ]

local tabel = Instance.new("Frame")
tabel.Name = "a4_Tabel"
tabel.Size = UDim2.new(1, 0, 0, 70)
tabel.BackgroundTransparency = 1
tabel.Parent = insetFrame

local input = Instance.new("Frame")
input.Name = "a3_Input&Send"
input.Size = UDim2.new(1, 0, 0, 50)
input.BackgroundColor3 = Color3.fromRGB(255,255,255)
input.BackgroundTransparency = 0.6
input.Parent = insetFrame
Corner(0, 8, input)
Stroke(input, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

local chat = Instance.new("Frame")
chat.Name = "a2_Chat"
chat.Size = UDim2.new(1, 0, 0, 300)
chat.BackgroundColor3 = Color3.fromRGB(255,255,255)
chat.BackgroundTransparency = 0.5
chat.Parent = insetFrame
Corner(0, 8, chat)
Stroke(chat,  ASMBorder, 255, 255, 255, LJMRound, 1, 0)
createUIListLayout(chat, 0, 5, HCenter, VCenter, SName, FillV)

local Scroll = Instance.new("ScrollingFrame")
Scroll.Name = "Chat"
Scroll.Size = UDim2.new(0.96, 0, 0.96, 0)
Scroll.BackgroundTransparency = 1
Scroll.ScrollBarThickness = 0
Scroll.ScrollingDirection = Enum.ScrollingDirection.Y
Scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll.Visible = true
Scroll.Parent = chat
createUIListLayout(Scroll, 0, 5, HCenter, VTop, SLayout, FillV)

local Scroll2 = Instance.new("ScrollingFrame")
Scroll2.Name = "Settings"
Scroll2.Size = UDim2.new(0.96, 0, 0.96, 0)
Scroll2.BackgroundTransparency = 1
Scroll2.ScrollBarThickness = 0
Scroll2.ScrollingDirection = Enum.ScrollingDirection.Y
Scroll2.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll2.Visible = false
Scroll2.Parent = chat
createUIListLayout(Scroll2, 0, 5, HCenter, VTop, SLayout, FillV)

local Scroll3 = Instance.new("ScrollingFrame")
Scroll3.Name = "More"
Scroll3.Size = UDim2.new(0.96, 0, 0.96, 0)
Scroll3.BackgroundTransparency = 1
Scroll3.ScrollBarThickness = 0
Scroll3.ScrollingDirection = Enum.ScrollingDirection.Y
Scroll3.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll3.Visible = false
Scroll3.Parent = chat
createUIListLayout(Scroll3, 0, 5, HCenter, VTop, SLayout, FillV)


-- =====FUNCTION CHAT AI AND PLAYER=====
-- NOTE: functions use global Scroll variable so ensure Scroll is created before calling them

local function ai(Text, Offset)
    Offset = tonumber(Offset) or 0
    local ai = Instance.new("Frame")
    ai.Name = "ai"
    ai.BackgroundColor3 = Color3.fromRGB(255,255,255)
    ai.BackgroundTransparency = 0.8
    -- ใส่ขนาด X scale + X offset และ Y height (เช่น 72px)
    ai.Size = UDim2.new(0.96, 0, 0, Offset or 60)
    ai.Parent = Scroll -- ต้องแน่ใจว่า Scroll มีอยู่แล้ว (สร้างก่อนเรียก)
    createUIListLayout(ai, 0, 10, HCenter, VCenter, SName, FillH)
    Stroke(ai, ASMBorder, 255, 255, 255, LJMRound, 1, 0) -- ใช้ LJMRound (ไม่ใช่ JSMRound)
    Corner(0, 8, ai)

    local image = Instance.new("ImageLabel")
    image.Name = "a1"
    image.Image = "rbxassetid://83032822916288" -- property ต้องใช้ Image
    image.Size = UDim2.new(0, 50, 0, 50)
    image.BackgroundTransparency = 0.8
    image.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    image.Parent = ai
    Corner(0, 8, image)
    Stroke(image, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

    local text = Instance.new("TextLabel")
    text.Name = "a2"
    text.Text = tostring(Text or "")
    text.Size = UDim2.new(0.88, -8, 1, 0) -- ปรับให้ fill แนวตั้ง
    text.BackgroundTransparency = 1
    text.TextSize = 15
    text.TextWrapped = true
    text.TextXAlignment = Enum.TextXAlignment.Left
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Parent = ai
    return ai
end

local function plr(Text, Offset)
    Offset = tonumber(Offset) or 0
    local plrFrame = Instance.new("Frame")
    plrFrame.Name = "plr"
    plrFrame.BackgroundColor3 = Color3.fromRGB(255,255,255)
    plrFrame.BackgroundTransparency = 0.8
    plrFrame.Size = UDim2.new(0.96, 0, 0, Offset or 60) -- ระบุ height ชัดเจน
    plrFrame.Parent = Scroll
    createUIListLayout(plrFrame, 0, 10, HCenter, VCenter, SName, FillH)
    Stroke(plrFrame, ASMBorder, 255, 255, 255, LJMRound, 1, 0)
    Corner(0, 8, plrFrame)

    local image = Instance.new("ImageLabel")
    image.Name = "a2"
    image.Image = "rbxassetid://135474395711579"
    image.Size = UDim2.new(0, 50, 0, 50)
    image.BackgroundTransparency = 0.8
    image.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    image.Parent = plrFrame
    Corner(0, 8, image)
    Stroke(image, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

    local text = Instance.new("TextLabel")
    text.Name = "a1"
    text.Text = tostring(Text or "")
    text.Size = UDim2.new(0.88, -8, 1, 0)
    text.BackgroundTransparency = 1
    text.TextSize = 15
    text.TextWrapped = true
    text.TextXAlignment = Enum.TextXAlignment.Right
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Parent = plrFrame
    return plrFrame
end

-- MESSAGE
local function mesg(Text, Offset, R, G, B, R1, G1, B1)
    Offset = tonumber(Offset) or 0
    local mesge = Instance.new("Frame")
    mesge.Name = "message"
    mesge.BackgroundColor3 = Color3.fromRGB(R, G, B or 255, 255, 255)
    mesge.BackgroundTransparency = 0.8
    mesge.Size = UDim2.new(0.96, 0, 0, Offset or 60) -- ระบุ height ชัดเจน
    mesge.Parent = Scroll
    createUIListLayout(mesge, 0, 10, HCenter, VCenter, SName, FillH)
    Stroke(mesge, ASMBorder, 255, 255, 255, LJMRound, 1, 0)
    Corner(0, 8, mesge)

    local text = Instance.new("TextLabel")
    text.Name = "a1"
    text.Text = tostring(Text or "")
    text.Size = UDim2.new(0.88, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextColor3 = Color3.fromRGB(R1, G1, B1 or 0, 0, 0)
    text.TextSize = 15
    text.TextWrapped = true
    text.TextXAlignment = Enum.TextXAlignment.Center
    text.TextYAlignment = Enum.TextYAlignment.Center
    text.Parent = mesge
    return mesg
end

-- =====END FUNCTION AI AND PLAYER + END INSETFRAME=====

-- [ INPUT ]
local box = Instance.new("TextBox")
box.Name = "Ask"
box.Size = UDim2.new(0.72, 0, 0.9, 0)
box.Position = UDim2.new(0.02, 0, 0.05, 0)
box.BackgroundTransparency = 1
box.PlaceholderColor3 = Color3.fromRGB(95,95,95)
box.PlaceholderText = "Ask anything..."
box.Text = ""
box.TextScaled = true
box.TextColor3 = Color3.fromRGB(0,0,0)
box.RichText = true
box.ClearTextOnFocus = false
box.Parent = input

local send = Instance.new("TextButton")
send.Name = "Send"
send.Size = UDim2.new(0.076, 0, 0.9, 0)
send.Position = UDim2.new(0.75, 0, 0.05, 0)
send.BackgroundTransparency = 0.6
send.TextScaled = true
send.Text = "✓"
send.TextColor3 = Color3.fromRGB(0,0,0)
send.Parent = input
Corner(0, 8, send)
Stroke(send, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

local clear = Instance.new("TextButton")
clear.Name = "clear"
clear.Size = UDim2.new(0.076, 0, 0.9, 0)
clear.Position = UDim2.new(0.835, 0, 0.05, 0)
clear.BackgroundTransparency = 0.6
clear.TextScaled = true
clear.Text = "×"
clear.TextColor3 = Color3.fromRGB(0,0,0)
clear.Parent = input
Corner(0, 8, clear)
Stroke(clear, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

local rec = Instance.new("TextButton")
rec.Name = "re-chat"
rec.Size = UDim2.new(0.076, 0, 0.9, 0)
rec.Position = UDim2.new(0.918, 0, 0.05, 0)
rec.BackgroundTransparency = 0.6
rec.TextScaled = true
rec.Text = "re-chat"
rec.TextColor3 = Color3.fromRGB(0,0,0)
rec.Parent = input
Corner(0, 8, rec)
Stroke(rec, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

mesg("Verison: Alpha Dev Test", 30, 76, 76, 76, 255, 255, 255)
mesg("copyright © ExperienceSettings-ChatGPT 2025", 30, 76, 76, 76, 255, 255, 255)
ai("I'm ready to chat with you!", 60)
mesg(" --[ New Chat ]--", 30, 0, 0, 0, 255, 255, 255)
mesg("Please Re-Chat before chatting.", 30, 0, 0, 0, 75, 75, 75)

local option = Instance.new("Frame")
option.Name = "a1_option"
option.Size = UDim2.new(1, 0, 0, 50)
option.BackgroundColor3 = Color3.fromRGB(255,255,255)
option.BackgroundTransparency = 1
option.Parent = insetFrame

local logo = Instance.new("Frame")
logo.Name = "a1.logo"
logo.Size = UDim2.new(0.2, 0, 0, 50)
logo.BackgroundColor3 = Color3.fromRGB(255,255,255)
logo.BackgroundTransparency = 0.6
logo.Parent = option
Corner(0, 8, logo)
Stroke(logo, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

local lotext = Instance.new("TextLabel")
lotext.Name = "Text"
lotext.Size = UDim2.new(0.9, 0, 0.9, 0)
lotext.Position = UDim2.new(0.05, 0, 0.05, 0)
lotext.BackgroundTransparency = 1
lotext.Text = "LighterCyan"
lotext.TextColor3 = Color3.fromRGB(255, 255, 255)
lotext.TextStrokeTransparency = 0
lotext.TextStrokeColor3 = Color3.fromRGB(85, 255, 255)
lotext.TextScaled = true
lotext.Parent = logo

-- =====FUNCTION TEXTBUTTON=====
local function btm(Name, Text, Pos)
    local btm1 = Instance.new("Frame")
    btm1.Name = tostring(Name or "")
    btm1.BackgroundColor3 = Color3.fromRGB(255,255,255)
    btm1.BackgroundTransparency = 0.6
    btm1.Size = UDim2.new(0.1, 0, 0, 50)
    btm1.Position = UDim2.new(Pos or 0, 0, 0, 0)
    btm1.Parent = option
    Corner(0, 8, btm1)
    Stroke(btm1, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

    local btm2 = Instance.new("TextButton")
    btm2.Size = UDim2.new(0.9, 0, 0.9, 0)
    btm2.Position = UDim2.new(0.05, 0, 0.05, 0)
    btm2.TextScaled = true
    btm2.BackgroundTransparency = 1
    btm2.Text = tostring(Text or "")
    btm2.Parent = btm1

    -- ใส่ Gradient ดำล้วน
    Gradient(btm2, 0, 0, 0, Color3.fromRGB(0,0,0), Color3.fromRGB(0,0,0))

    return btm1
end

btm("a2.Chat", "🗨️ Chat", 0)
btm("a3.Settings", "⚙️ Settings", 0)
btm("a4.Explorer", "🌏 Explorer", 0)
btm("a50.More", "📦 More", 0)
createUIListLayout(option, 0, 5, HLeft, VCenter, SName, FillH) -- btw Scaled 0 because UIListLayout haha, now go back to work.


-- LighterCyan Full Controller (ai/plr labels separated)
-- v3 - single-file LocalScript; paste into executor or LocalScript after GUI/ai_runtime ready.

local DEBUG = false
local GUI_WAIT_TIMEOUT = 12
local THINKING_BASE = "Thinking"
local THINK_MARK = "LC_Controller_Thinking"

local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local TextService = game:GetService("TextService")

local player = Players.LocalPlayer
if not player then warn("[LC] No LocalPlayer; aborting"); return end

local function dbg(...)
    if not DEBUG then return end
    local a = {...}
    local parts = {"[LC]"}
    for i=1,#a do parts[#parts+1] = tostring(a[i]) end
    pcall(function() print(table.unpack(parts)) end)
end

-- forward declare public ThinkAsync
local ThinkAsync

-- ========== bindable helpers (vararg-safe) ==========
local function get_ai_runtime_folder()
    local f = player:FindFirstChild("ai_runtime")
    if f then return f end
    local ok,res = pcall(function() return player:WaitForChild("ai_runtime",2) end)
    if ok then return res end
    return nil
end

local function wait_for_bindable(name, timeout)
    local folder = get_ai_runtime_folder()
    if not folder then return nil end
    local obj = folder:FindFirstChild(name)
    if obj then return obj end
    local ok,res = pcall(function() return folder:WaitForChild(name, timeout or 3) end)
    if ok then return res end
    return folder:FindFirstChild(name)
end

local function safe_invoke_bindable(fnName, ...)
    local fn = wait_for_bindable(fnName, 1)
    if fn and fn:IsA("BindableFunction") then
        local args = {...}
        local ok, res = pcall(fn.Invoke, fn, table.unpack(args))
        return ok, res
    end
    return false, "bindable not found"
end

local function safe_fire_bindable(evName, ...)
    local ev = wait_for_bindable(evName, 1)
    if ev and ev:IsA("BindableEvent") then
        local args = {...}
        local ok, res = pcall(ev.Fire, ev, table.unpack(args))
        return ok, res
    end
    return false, "bindable not found"
end

-- ========== GUI discovery helpers ==========
local function get_lightercyan_inset()
    local ok, base = pcall(function()
        if not CoreGui.TopBarApp then return nil end
        local t = CoreGui.TopBarApp.TopBarApp
        if not t then return nil end
        t = t.UnibarLeftFrame
        if not t then return nil end
        t = t.HealthBar
        if not t then return nil end
        t = t.ExperienceSettings
        if not t then return nil end
        t = t["LighterCyan.ai"]
        if not t then return nil end
        t = t.Holder
        if not t then return nil end
        t = t.InsetFrame
        return t
    end)
    if ok then return base end
    return nil
end

local function wait_for_gui(timeout)
    timeout = timeout or GUI_WAIT_TIMEOUT
    local t0 = tick()
    repeat
        local inset = get_lightercyan_inset()
        if inset then return inset end
        task.wait(0.06)
    until tick()-t0 > timeout
    return nil
end

local function find_scroll_frame()
    local inset = get_lightercyan_inset()
    if not inset then return nil end
    local chat = inset:FindFirstChild("a2_Chat")
    if not chat then
        for _,v in ipairs(inset:GetDescendants()) do
            if v.Name == "Chat" and v:IsA("ScrollingFrame") then chat = v; break end
        end
    end
    local scroll = chat and chat:FindFirstChild("Chat") or chat
    if scroll and scroll:IsA("ScrollingFrame") then return scroll end
    if chat and chat:IsA("ScrollingFrame") then return chat end
    return nil
end

-- read latest text (considers both ai and plr label names)
local function read_latest_textlabel(scroll)
    if not scroll then return "" end
    for i = #scroll:GetChildren(), 1, -1 do
        local c = scroll:GetChildren()[i]
        for _,d in ipairs(c:GetDescendants()) do
            if d:IsA("TextLabel") and (d.Name == "a2_ai" or d.Name == "a2_plr") then
                return tostring(d.Text)
            end
        end
    end
    return ""
end

-- update canvas size safely
local function update_canvas(scroll)
    if not scroll or not scroll:IsA("ScrollingFrame") then return end
    local layout = scroll:FindFirstChildOfClass("UIListLayout")
    if not layout then
        task.defer(function()
            local totalY = 0
            for _,c in ipairs(scroll:GetChildren()) do
                if c:IsA("Frame") then totalY = totalY + (c.AbsoluteSize.Y or 40) + 8 end
            end
            pcall(function() scroll.CanvasSize = UDim2.new(0,0,0, math.max(totalY, scroll.AbsoluteSize.Y)) end)
        end)
        return
    end
    task.defer(function()
        local ok, size = pcall(function() return layout.AbsoluteContentSize end)
        if ok and size then
            pcall(function()
                scroll.CanvasSize = UDim2.new(0,0,0, math.max(size.Y + 8, scroll.AbsoluteSize.Y))
                scroll.CanvasPosition = Vector2.new(0, math.max(0, size.Y - scroll.AbsoluteSize.Y))
            end)
        end
    end)
end

-- safe auto-size label
local function safe_auto_size_label(lbl)
    pcall(function()
        if lbl and lbl:IsA("TextLabel") then
            lbl.TextWrapped = true
            pcall(function() lbl.AutomaticSize = Enum.AutomaticSize.Y end)
        end
    end)
end

local function compute_text_height(text, width, textSize, font)
    if not text then return 0 end
    local size = Vector2.new(math.max(10, width or 200), math.huge)
    local ok, ts = pcall(function() return TextService:GetTextSize(tostring(text), textSize or 18, font or Enum.Font.SourceSans, size) end)
    if ok and ts then return ts.Y end
    return (textSize or 18) * 1.2
end

-- ========== Frame creation (ai/plr/mesg) ==========
-- We use distinct TextLabel names:
--  - ai:   image "a1", text "a2_ai"
--  - plr:  image "p1", text "a2_plr"
--  - mesg: image "m1", text "a2_msg"
local function mark_frame(frame)
    pcall(function() frame:SetAttribute(THINK_MARK, true) end)
end
local function is_our_frame(frame)
    if not frame then return false end
    local ok,val = pcall(function() return frame:GetAttribute(THINK_MARK) end)
    return ok and val
end

local function ensure_scroll_global()
    if typeof(Scroll) == "Instance" and Scroll:IsA("ScrollingFrame") then return Scroll end
    local sc = find_scroll_frame()
    if sc then Scroll = sc; return sc end
    return nil
end

local function create_ai_frame(text, heightPx)
    local sc = ensure_scroll_global()
    if not sc then warn("[LC] create_ai_frame: Scroll not found"); return nil end
    -- reuse existing our-marked ai frame if present
    for _,c in ipairs(sc:GetChildren()) do
        if c:IsA("Frame") and is_our_frame(c) and c.Name == "ai" then
            -- update text label if exists
            local lbl = c:FindFirstChild("a2_ai", true)
            if lbl and lbl:IsA("TextLabel") then
                lbl.Text = tostring(text or "")
                safe_auto_size_label(lbl)
                -- recompute height
                local scW = sc.AbsoluteSize and sc.AbsoluteSize.X or 400
                local h = math.ceil(compute_text_height(lbl.Text, scW*0.88, lbl.TextSize, lbl.Font)) + 18
                pcall(function() c.Size = UDim2.new(0.96,0,0,h) end)
                update_canvas(sc)
                return c
            end
        end
    end
    -- create
    local frame = Instance.new("Frame"); frame.Name = "ai"; frame.BackgroundTransparency = 0.8; frame.BackgroundColor3 = Color3.new(1,1,1); frame.Parent = sc
    local icon = Instance.new("ImageLabel"); icon.Name = "a1"; icon.Size = UDim2.new(0,50,0,50); icon.Position = UDim2.new(0,6,0,6); icon.BackgroundTransparency = 1; icon.Image = "rbxassetid://83032822916288"; icon.Parent = frame
    local lbl = Instance.new("TextLabel"); lbl.Name = "a2_ai"; lbl.Text = tostring(text or ""); lbl.BackgroundTransparency = 1; lbl.TextWrapped = true; lbl.TextXAlignment = Enum.TextXAlignment.Left; lbl.TextYAlignment = Enum.TextYAlignment.Top; lbl.TextSize = 18; lbl.Font = Enum.Font.SourceSans; lbl.Parent = frame
    lbl.Size = UDim2.new(0.88, -8, 1, -12); lbl.Position = UDim2.new(0,56,0,6)
    safe_auto_size_label(lbl)
    local scW = sc.AbsoluteSize and sc.AbsoluteSize.X or 400
    local h = math.ceil(compute_text_height(lbl.Text, scW*0.88, lbl.TextSize, lbl.Font)) + 18
    frame.Size = UDim2.new(0.96,0,0,h)
    mark_frame(frame)
    update_canvas(sc)
    return frame
end

local function create_plr_frame(text, heightPx)
    local sc = ensure_scroll_global()
    if not sc then warn("[LC] create_plr_frame: Scroll not found"); return nil end
    -- create new frame (player messages usually many; we still mark)
    local frame = Instance.new("Frame"); frame.Name = "plr"; frame.BackgroundTransparency = 0.8; frame.BackgroundColor3 = Color3.new(1,1,1); frame.Parent = sc
    local icon = Instance.new("ImageLabel"); icon.Name = "p1"; icon.Size = UDim2.new(0,50,0,50); icon.Position = UDim2.new(0,6,0,6); icon.BackgroundTransparency = 1; icon.Image = "rbxassetid://135474395711579"; icon.Parent = frame
    local lbl = Instance.new("TextLabel"); lbl.Name = "a2_plr"; lbl.Text = tostring(text or ""); lbl.BackgroundTransparency = 1; lbl.TextWrapped = true; lbl.TextXAlignment = Enum.TextXAlignment.Right; lbl.TextYAlignment = Enum.TextYAlignment.Top; lbl.TextSize = 18; lbl.Font = Enum.Font.SourceSans; lbl.Parent = frame
    lbl.Size = UDim2.new(0.88, -8, 1, -12); lbl.Position = UDim2.new(0,56,0,6)
    safe_auto_size_label(lbl)
    local scW = sc.AbsoluteSize and sc.AbsoluteSize.X or 400
    local h = math.ceil(compute_text_height(lbl.Text, scW*0.88, lbl.TextSize, lbl.Font)) + 18
    frame.Size = UDim2.new(0.96,0,0,h)
    mark_frame(frame)
    update_canvas(sc)
    return frame
end

local function create_mesg_frame(text, heightPx, textColor, bgColor)
    local sc = ensure_scroll_global()
    if not sc then warn("[LC] create_mesg_frame: Scroll not found"); return nil end
    local frame = Instance.new("Frame"); frame.Name = "message"; frame.BackgroundTransparency = 0.8; frame.BackgroundColor3 = bgColor or Color3.new(1,1,1); frame.Parent = sc
    local lbl = Instance.new("TextLabel"); lbl.Name = "a2_msg"; lbl.Text = tostring(text or ""); lbl.BackgroundTransparency = 1; lbl.TextWrapped = true; lbl.TextXAlignment = Enum.TextXAlignment.Center; lbl.TextYAlignment = Enum.TextYAlignment.Center; lbl.TextSize = 16; lbl.Font = Enum.Font.SourceSans; lbl.Parent = frame
    if textColor then pcall(function() lbl.TextColor3 = textColor end) end
    lbl.Size = UDim2.new(0.88, -8, 1, -12); lbl.Position = UDim2.new(0,56,0,6)
    safe_auto_size_label(lbl)
    local scW = sc.AbsoluteSize and sc.AbsoluteSize.X or 400
    local h = math.ceil(compute_text_height(lbl.Text, scW*0.88, lbl.TextSize, lbl.Font)) + 18
    frame.Size = UDim2.new(0.96,0,0,h)
    mark_frame(frame)
    update_canvas(sc)
    return frame
end

-- Expose global functions so controller can call them if needed
_G.ai = function(Text, Offset) return create_ai_frame(Text, Offset) end
_G.plr = function(Text, Offset) return create_plr_frame(Text, Offset) end
_G.mesg = function(Text, Offset, R,G,B, R1,G1,B1)
    local bg = nil; local textColor = nil
    if R and G and B then bg = Color3.fromRGB(tonumber(R) or 255, tonumber(G) or 255, tonumber(B) or 255) end
    if R1 and G1 and B1 then textColor = Color3.fromRGB(tonumber(R1) or 0, tonumber(G1) or 0, tonumber(B1) or 0) end
    return create_mesg_frame(Text, Offset, textColor, bg)
end

-- ========== calling wrappers used earlier ==========
local function call_ai_func(text, timeSec) if type(_G.ai) == "function" then pcall(_G.ai, text, timeSec); update_canvas(find_scroll_frame()); return true end; return false end
local function call_plr_func(text, timeSec) if type(_G.plr) == "function" then pcall(_G.plr, text, timeSec); update_canvas(find_scroll_frame()); return true end; return false end
local function call_mesg_func(text, timeSec, R,G,B,R1,G1,B1) if type(_G.mesg) == "function" then pcall(_G.mesg, text, timeSec, R,G,B,R1,G1,B1); update_canvas(find_scroll_frame()); return true end; return false end

-- ========== single-thinking controller (reuse and update the ai text "a2_ai") ==========
local currentJob = nil
local jobTokenCounter = 0
local function cancel_current_job()
    if currentJob and currentJob.cancel then pcall(function() currentJob.cancel() end) end
    currentJob = nil
end

local function find_existing_ai_frame(baseThinking)
    local sc = find_scroll_frame()
    if not sc then return nil end
    for i = #sc:GetChildren(), 1, -1 do
        local c = sc:GetChildren()[i]
        if c and c:IsA("Frame") then
            -- prefer our frames (marked) with name "ai"
            if is_our_frame(c) and c.Name == "ai" then return c end
            -- else check text labels named a2_ai starting with baseThinking
            for _,d in ipairs(c:GetDescendants()) do
                if d:IsA("TextLabel") and d.Name == "a2_ai" and tostring(d.Text):match("^"..baseThinking) then return c end
            end
        end
    end
    return nil
end

local function staged_status_loop(token, stages, baseThinking)
    local running = true
    local idx = 1
    local sc = find_scroll_frame()
    local frame = nil

    -- reuse our marked ai frame first
    if sc then
        for _,c in ipairs(sc:GetChildren()) do
            if c:IsA("Frame") and is_our_frame(c) and c.Name == "ai" then frame = c; break end
        end
    end
    if not frame then frame = find_existing_ai_frame(baseThinking) end
    if not frame then frame = create_ai_frame(baseThinking.." (0s)") end
    if frame then currentJob = currentJob or {}; currentJob.frame = frame end

    local function updateText(txt)
        if token.canceled then return end
        if frame and frame.Parent then
            pcall(function()
                local lbl = nil
                for _,d in ipairs(frame:GetDescendants()) do
                    if d:IsA("TextLabel") and d.Name == "a2_ai" then lbl = d; break end
                end
                if lbl then
                    lbl.Text = tostring(txt or "")
                    safe_auto_size_label(lbl)
                    task.wait(0.02)
                    local scW = (find_scroll_frame() and find_scroll_frame().AbsoluteSize and find_scroll_frame().AbsoluteSize.X) or 400
                    local h = math.ceil(compute_text_height(lbl.Text, scW*0.88, lbl.TextSize, lbl.Font)) + 18
                    pcall(function() frame.Size = UDim2.new(0.96,0,0,h) end)
                    update_canvas(find_scroll_frame())
                else
                    call_ai_func(txt, 60)
                end
            end)
        else
            call_ai_func(txt, 60)
        end
    end

    -- timer
    local timerThread = task.spawn(function()
        local start = tick()
        while running and not token.canceled do
            local s = math.floor(tick() - start)
            updateText(baseThinking.." ("..tostring(s).."s)")
            task.wait(1)
        end
    end)

    -- stages
    local stageThread = task.spawn(function()
        while running and not token.canceled do
            local st = stages[idx]
            if st then updateText(st); idx = idx + 1 end
            for i=1,6 do if token.canceled then break end; task.wait(0.2) end
        end
    end)

    local function cancel() running=false; token.canceled=true end
    return { cancel = cancel, frame = frame, token = token }
end

-- ========== error mapping & rate-limit ==========
local function map_http_error(errstr)
    if not errstr then return "ERROR 500: INTERNAL SERVER ERROR" end
    local s = tostring(errstr):lower()
    if s:match("timed out") or s:match("timeout") then return "ERROR0 408: REQUEST TIMEOUT" end
    if s:match("404") or s:match("not found") then return "ERROR 404: NOT FOUND OR FAILED TO GET URL" end
    if s:match("401") or s:match("unauthorized") then return "ERROR 401: UNAUTHORIZED" end
    if s:match("400") then return "ERROR 400: BAD REQUEST" end
    if s:match("502") then return "ERROR 502: BAD GATEWAY" end
    if s:match("503") then return "ERROR 503: SERVICE UNAVAILABLE" end
    if s:match("504") then return "ERROR 504: GATEWAY TIMEOUT" end
    return "ERROR 500: INTERNAL SERVER ERROR"
end

local messageTimestamps = {}
local function record_message_timestamp()
    table.insert(messageTimestamps, os.time())
    local now = os.time(); local keep = {}
    for _,v in ipairs(messageTimestamps) do if now - v <= 60 then keep[#keep+1] = v end end
    messageTimestamps = keep
    return #messageTimestamps
end

local function check_rate_limit()
    local n = record_message_timestamp()
    if n > 50 then return false, "ERROR 1" end
    return true
end

-- ========== URL detection & fetch ==========
local ALLOWED_DOMAINS = {
    "en.help.roblox.com","youtube.com","youtu.be","create.roblox.com","x.com","chatgpt.com","chat.openai.com"
}
local function detect_url_in_text(text)
    if not text then return nil end
    local s = tostring(text)
    for url in s:gmatch("https?://[%w%p]+") do
        local lower = url:lower()
        for _,dom in ipairs(ALLOWED_DOMAINS) do if lower:find(dom,1,true) then return url end end
    end
    for _,dom in ipairs(ALLOWED_DOMAINS) do if s:lower():find(dom,1,true) then return "https://"..dom end end
    return nil
end

local function fetch_url_with_status(url, token)
    local stages = {"Searching URL...","Getting Data...","Readying...","Getting Answers..."}
    local job = staged_status_loop(token, stages, THINKING_BASE)
    local tries = 2; local lastErr = nil
    for i=1,tries do
        if token.canceled then break end
        local ok, res = pcall(function() return HttpService:GetAsync(url, true) end)
        if ok and res then return true, res, nil, job end
        lastErr = res
        local ok2,res2 = pcall(function() return game:HttpGet(url) end)
        if ok2 and res2 then return true, res2, nil, job end
        lastErr = res2
        task.wait(0.25 * i)
    end
    return false, nil, lastErr, job
end

-- ========== compute pipeline (simple local logic) ==========
local function compute_answer_pipeline(input, context, token)
    -- try supervised
    local okPred, predRes = pcall(function()
        local fn = wait_for_bindable("ai.Learning_Supervised_Predict")
        if fn and fn:IsA("BindableFunction") then return fn:Invoke(input) end
        return nil
    end)
    if okPred and predRes and tostring(predRes) ~= "" then return tostring(predRes) end

    -- unsupervised
    local okTopics, topics = pcall(function()
        local fn = wait_for_bindable("ai.Unsupervised_GetTopics")
        if fn and fn:IsA("BindableFunction") then return fn:Invoke(5) end
        return nil
    end)
    if okTopics and topics and #topics>0 then local top = (topics[1].w or topics[1]) or ""; return "Main topic: "..tostring(top) end

    -- local datastore
    local okAll, resAll = safe_invoke_bindable("ai.DataStorage_Get")
    local examples = nil
    if okAll and resAll then examples = resAll[1] or resAll end
    if examples then
        local q = tostring(input or ""):lower()
        for _,ex in ipairs(examples) do
            local ttxt = tostring(ex.text or ex):lower()
            if q ~= "" and ttxt:find(q,1,true) then return "Found related: "..ttxt:sub(1,300) end
        end
    end
    return nil
end

-- ========== ThinkAsync main ==========
local MAX_COMPUTE_GRACE = 30
local ALLOW_UNBOUNDED = false

ThinkAsync = function(input, context)
    if not input then return end
    if not check_rate_limit() then show_lighter_error(1); return end

    cancel_current_job()
    jobTokenCounter = jobTokenCounter + 1
    local token = { id = jobTokenCounter, canceled = false }
    currentJob = { token = token, cancel = function() token.canceled = true end }

    local maybeUrl = detect_url_in_text(input)
    if maybeUrl then
        local okF, content, ferr, jobHandle = fetch_url_with_status(maybeUrl, token)
        if token.canceled then if jobHandle then pcall(jobHandle.cancel) end; currentJob=nil; return end
        if not okF then
            local errMsg = map_http_error(ferr)
            create_mesg_frame(errMsg, 60, nil, Color3.fromRGB(1,0.95,0.9)) -- show in UI
            if jobHandle then pcall(jobHandle.cancel) end
            currentJob=nil; return
        end
        pcall(function() safe_invoke_bindable("ai.DataStorage_Add", content, {source=maybeUrl, time=os.time()}) end)
        local ans = compute_answer_pipeline("", content, token) or "No focused answer from fetched content."
        if jobHandle then pcall(jobHandle.cancel) end
        create_ai_frame(ans, 60)
        currentJob=nil; return
    end

    local stages = {"Analyzing context...","Searching memory...","Preparing answer...","Finalizing..."}
    local jobHandle = staged_status_loop(token, stages, THINKING_BASE)

    task.spawn(function()
        local start = tick(); local timedOut = false; local result = nil
        local co = coroutine.create(function() result = compute_answer_pipeline(input, context, token) end)
        coroutine.resume(co)
        while coroutine.status(co) ~= "dead" and not token.canceled do
            if not ALLOW_UNBOUNDED and MAX_COMPUTE_GRACE and (tick()-start) > MAX_COMPUTE_GRACE then timedOut = true; break end
            task.wait(0.12)
        end
        if token.canceled then if jobHandle then pcall(jobHandle.cancel) end; currentJob=nil; return end
        if timedOut then create_mesg_frame("ERROR -1: TIMEOUT (overthinking)", 60, nil, Color3.fromRGB(1,0.95,0.9)); if jobHandle then pcall(jobHandle.cancel) end; currentJob=nil; return end
        local finalAnswer = result or "Sorry, couldn't find an answer. Try /fetch <url> or add more context."
        if jobHandle and jobHandle.frame then
            pcall(function()
                local frame = jobHandle.frame
                local lbl = nil
                for _,d in ipairs(frame:GetDescendants()) do
                    if d:IsA("TextLabel") and d.Name == "a2_ai" then lbl = d; break end
                end
                if lbl then
                    lbl.Text = finalAnswer
                    safe_auto_size_label(lbl)
                    task.wait(0.02)
                    local scW = (find_scroll_frame() and find_scroll_frame().AbsoluteSize and find_scroll_frame().AbsoluteSize.X) or 400
                    local h = math.ceil(compute_text_height(lbl.Text, scW*0.88, lbl.TextSize, lbl.Font)) + 18
                    pcall(function() frame.Size = UDim2.new(0.96,0,0,h) end)
                    update_canvas(find_scroll_frame())
                else
                    create_ai_frame(finalAnswer, 60)
                end
            end)
        else
            create_ai_frame(finalAnswer, 60)
        end
        if jobHandle then pcall(jobHandle.cancel) end
        currentJob=nil
    end)
end

-- ========== GUI hook (send/clear/re-chat) ==========
local function safe_connect_mouse(btn, fn)
    if not btn then return end
    pcall(function()
        if typeof(btn.MouseButton1Click) == "RBXScriptSignal" then btn.MouseButton1Click:Connect(fn)
        elseif btn:IsA("TextButton") then btn.Activated:Connect(fn) end
    end)
end

local function hook_gui_handlers()
    local inset = wait_for_gui(GUI_WAIT_TIMEOUT)
    if not inset then warn("[LC] GUI not found; hooks disabled"); return false end
    local inputFrame = inset:FindFirstChild("a3_Input&Send")
    if not inputFrame then
        for _,v in ipairs(inset:GetDescendants()) do if v.Name=="a3_Input&Send" and v:IsA("Frame") then inputFrame=v; break end end
    end
    if not inputFrame then warn("[LC] input frame missing"); return false end

    local AskBox = inputFrame:FindFirstChild("Ask")
    local SendBtn = inputFrame:FindFirstChild("Send")
    local ClearBtn = inputFrame:FindFirstChild("clear") or inputFrame:FindFirstChild("Clear")
    local RecBtn = inputFrame:FindFirstChild("re-chat") or inputFrame:FindFirstChild("rec")

    safe_connect_mouse(SendBtn, function()
        local txt = ""; pcall(function() if AskBox and AskBox:IsA("TextBox") then txt = AskBox.Text end end)
        if txt and tostring(txt):match("%S") then
            local latest = ""
            pcall(function() latest = read_latest_textlabel(find_scroll_frame()) or "" end)
            if type(ThinkAsync) == "function" then pcall(ThinkAsync, txt, latest) else create_plr_frame(txt, 60) end
        end
        pcall(function() if AskBox and AskBox:IsA("TextBox") then AskBox.Text = "" end end)
    end)

    safe_connect_mouse(ClearBtn, function()
        pcall(function() if AskBox and AskBox:IsA("TextBox") then AskBox.Text = "" end end)
    end)

    safe_connect_mouse(RecBtn, function()
        local sc = find_scroll_frame()
        if sc then
            pcall(function()
                for _,c in ipairs(sc:GetChildren()) do
                    if c:IsA("Frame") then
                        local ok,val = pcall(function() return c:GetAttribute(THINK_MARK) end)
                        if ok and val then pcall(function() c:Destroy() end) end
                    end
                end
            end)
            update_canvas(sc)
        end
    end)

    if AskBox and AskBox:IsA("TextBox") then
        pcall(function()
            AskBox.FocusLost:Connect(function(enter)
                if not enter then return end
                local t = ""; pcall(function() t = AskBox.Text or "" end)
                if not t:match("%S") then return end
                local latest = ""; pcall(function() latest = read_latest_textlabel(find_scroll_frame()) or "" end)
                if type(ThinkAsync) == "function" then pcall(ThinkAsync, t, latest) else create_plr_frame(t, 60) end
                pcall(function() AskBox.Text = "" end)
            end)
        end)
    end

    dbg("GUI hooks installed")
    return true
end

-- warm DataStorage if present
pcall(function() wait_for_bindable("ai.DataStorage_Get") end)

-- re-hook loop
task.spawn(function()
    while task.wait(2) do
        local inset = get_lightercyan_inset()
        if inset then hook_gui_handlers(); task.wait(4) end
    end
end)

print("[LC.Controller final] Ready")
