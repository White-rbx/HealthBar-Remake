-- string starting//
-- string:LighterCyan:ai(1)
-- Parent Finder
local Ex = game:GetService("CoreGui").TopBarApp.TopBarApp.UnibarLeftFrame.HealthBar.ExperienceSettings

--[[
Error, Warn and Information Detectors
~~~~~~~~~~~~~~~~~~
Error: 0
Warn: 0
Information: 0
~~~~~~~~~~~~~~~~~~
Script state: Good
~~~~~~~~~~~~~~~~~~
]]

-- ====FUNCTION CORNER=====
local function Corner(Scale, Offset, Parent)
  local Corner = Instance.new("UICorner")
  Corner.CornerRadius = UDim.new(Scale or 0, Offset or 0)
  Corner.Parent = Parent
  return Corner
end
-- =====END FUNCTION CORNER====

-- =====FUNCTION UILISTLAYOUT=====
local HCenter = Enum.HorizontalAlignment.Center
local VCenter = Enum.VerticalAlignment.Center
local HLeft = Enum.HorizontalAlignment.Left
local VTop = Enum.VerticalAlignment.Top
local HRight = Enum.HorizontalAlignment.Right
local VBottom = Enum.VerticalAlignment.Bottom
local FillH = Enum.FillDirection.Horizontal
local FillV = Enum.FillDirection.Vertical
local SCustom = Enum.SortOrder.Custom
local SLayout = Enum.SortOrder.LayoutOrder
local SName = Enum.SortOrder.Name

local function createUIListLayout(parent, scale, offset, HZ, VT, SO, FILL)
    local list = Instance.new("UIListLayout")
    list.Padding = UDim.new(scale or 0, offset or 0)
    list.FillDirection = FILL or FillH
    list.HorizontalAlignment = HZ or HCenter
    list.VerticalAlignment = VT or VCenter
    list.SortOrder = SO or SName
    list.Parent = parent
    return list
end
-- =====END FUNCTION UILISTLAYOUT=====

-- ====FUNCTION UISTROKE=====
local ASMBorder = Enum.ApplyStrokeMode.Border
local ASMContextual = Enum.ApplyStrokeMode.Contextual

local LJMBevel = Enum.LineJoinMode.Bevel
local LJMMiter = Enum.LineJoinMode.Miter
local LJMRound = Enum.LineJoinMode.Round

local function Stroke(parent, ASM, R, G, B, LJM, Tn, Transy)
    local stroke = parent:FindFirstChildOfClass("UIStroke") or Instance.new("UIStroke")
    stroke.ApplyStrokeMode = ASM or ASMBorder
    stroke.Color = Color3.fromRGB(R or 255, G or 255, B or 255)
    stroke.LineJoinMode = LJM or LJMRound
    stroke.Thickness = Tn or 1
    stroke.Transparency = Transy or 0
    stroke.Parent = parent
    return stroke
end
-- =====END FUNCTION UISTROKE=====

-- ====FUNCTION UIGRADIENT=====
local function Gradient(parent, rotation, offsetX, offsetY, ...)
    local grad = parent:FindFirstChildOfClass("UIGradient") or Instance.new("UIGradient")
    grad.Rotation = rotation or 0
    grad.Offset = Vector2.new(offsetX or 0, offsetY or 0)

    local colors = {...}
    local keypoints = {}

    if #colors == 0 then
        keypoints = { ColorSequenceKeypoint.new(0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1, Color3.new(1,1,1)) }
    elseif #colors == 1 then
        keypoints = { ColorSequenceKeypoint.new(0, colors[1]), ColorSequenceKeypoint.new(1, colors[1]) }
    else
        for i, c in ipairs(colors) do
            local t = (i-1) / (#colors-1)
            table.insert(keypoints, ColorSequenceKeypoint.new(t, c))
        end
    end

    grad.Color = ColorSequence.new(keypoints)
    grad.Parent = parent
    return grad
end
-- =====END FUNCTION UIGRADIENT=====

-- ====FUNCTION UIPADDING (ตามลำดับ Roblox)=====
local function Padding(parent, bottom, left, right, top)
    local pad = parent:FindFirstChildOfClass("UIPadding") or Instance.new("UIPadding")
    local function toUDim(value)
        if typeof(value) == "UDim" then
            return value
        elseif type(value) == "number" then
            return UDim.new(0, value)
        elseif type(value) == "table" and #value >= 2 then
            return UDim.new(value[1] or 0, value[2] or 0)
        else
            return UDim.new(0, 0)
        end
    end

    pad.PaddingBottom = toUDim(bottom)
    pad.PaddingLeft   = toUDim(left)
    pad.PaddingRight  = toUDim(right)
    pad.PaddingTop    = toUDim(top)

    pad.Parent = parent
    return pad
end
-- =====END FUNCTION UIPADDING=====

-- Instance
local Gui = Instance.new("ScreenGui")
Gui.Name = "LighterCyan.ai"
Gui.ResetOnSpawn = false
Gui.Parent = Ex -- Ex คือ PlayerGui ในสคริปต์นี้
createUIListLayout(Gui, 0, 5, HCenter, VBottom, SName, FillV)

local useless = Instance.newscripte")
useless.Name = "Holder"
useless.Size = UDim2.new(0.5, 0, 0.9, 0)
useless.BackgroundTransparency = 1 -- แก้จาก .Transparency
useless.Active = false
useless.Parent = Gui
createUIListLayout(useless, 0, 5, HCenter, VCenter, SName, FillV)

local insetFrame = Instance.new("Frame")
insetFrame.Name = "InsetFrame"
insetFrame.Size = UDim2.new(0.96, 0, 1, 0)
insetFrame.BackgroundTransparency = 1
insetFrame.Parent = useless
createUIListLayout(insetFrame, 0, 5, HCenter, VBottom, SName, FillV)

-- [ INSETFRAME ]

local tabel = Instance.new("Frame")
tabel.Name = "a4_Tabel"
tabel.Size = UDim2.new(1, 0, 0, 70)
tabel.BackgroundTransparency = 1
tabel.Parent = insetFrame

local input = Instance.new("Frame")
input.Name = "a3_Input&Send"
input.Size = UDim2.new(1, 0, 0, 50)
input.BackgroundColor3 = Color3.fromRGB(255,255,255)
input.BackgroundTransparency = 0.6
input.Parent = insetFrame
Corner(0, 8, input)
Stroke(input, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

local chat = Instance.new("Frame")
chat.Name = "a2_Chat"
chat.Size = UDim2.new(1, 0, 0, 300)
chat.BackgroundColor3 = Color3.fromRGB(255,255,255)
chat.BackgroundTransparency = 0.5
chat.Parent = insetFrame
Corner(0, 8, chat)
Stroke(chat,  ASMBorder, 255, 255, 255, LJMRound, 1, 0)
createUIListLayout(chat, 0, 5, HCenter, VCenter, SName, FillV)

local Scroll = Instance.new("ScrollingFrame")
Scroll.Name = "Chat"
Scroll.Size = UDim2.new(0.96, 0, 0.96, 0)
Scroll.BackgroundTransparency = 1
Scroll.ScrollBarThickness = 0
Scroll.ScrollingDirection = Enum.ScrollingDirection.Y
Scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll.Visible = true
Scroll.Parent = chat
createUIListLayout(Scroll, 0, 5, HCenter, VTop, SLayout, FillV)

local Scroll2 = Instance.new("ScrollingFrame")
Scroll2.Name = "Settings"
Scroll2.Size = UDim2.new(0.96, 0, 0.96, 0)
Scroll2.BackgroundTransparency = 1
Scroll2.ScrollBarThickness = 0
Scroll2.ScrollingDirection = Enum.ScrollingDirection.Y
Scroll2.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll2.Visible = false
Scroll2.Parent = chat
createUIListLayout(Scroll2, 0, 5, HCenter, VTop, SLayout, FillV)

local Scroll3 = Instance.new("ScrollingFrame")
Scroll3.Name = "More"
Scroll3.Size = UDim2.new(0.96, 0, 0.96, 0)
Scroll3.BackgroundTransparency = 1
Scroll3.ScrollBarThickness = 0
Scroll3.ScrollingDirection = Enum.ScrollingDirection.Y
Scroll3.CanvasSize = UDim2.new(0, 0, 0, 0)
Scroll3.Visible = false
Scroll3.Parent = chat
createUIListLayout(Scroll3, 0, 5, HCenter, VTop, SLayout, FillV)


-- =====FUNCTION CHAT AI AND PLAYER=====
-- NOTE: functions use global Scroll variable so ensure Scroll is created before calling them

local function ai(Text, Offset)
    Offset = tonumber(Offset) or 0
    local ai = Instance.new("Frame")
    ai.Name = "ai"
    ai.BackgroundColor3 = Color3.fromRGB(255,255,255)
    ai.BackgroundTransparency = 0.8
    -- ใส่ขนาด X scale + X offset และ Y height (เช่น 72px)
    ai.Size = UDim2.new(0.96, 0, 0, Offset or 60)
    ai.Parent = Scroll -- ต้องแน่ใจว่า Scroll มีอยู่แล้ว (สร้างก่อนเรียก)
    createUIListLayout(ai, 0, 10, HCenter, VCenter, SName, FillH)
    Stroke(ai, ASMBorder, 255, 255, 255, LJMRound, 1, 0) -- ใช้ LJMRound (ไม่ใช่ JSMRound)
    Corner(0, 8, ai)

    local image = Instance.new("ImageLabel")
    image.Name = "a1"
    image.Image = "rbxassetid://83032822916288" -- property ต้องใช้ Image
    image.Size = UDim2.new(0, 50, 0, 50)
    image.BackgroundTransparency = 0.8
    image.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    image.Parent = ai
    Corner(0, 8, image)
    Stroke(image, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

    local text = Instance.new("TextLabel")
    text.Name = "a2"
    text.Text = tostring(Text or "")
    text.Size = UDim2.new(0.88, -8, 1, 0) -- ปรับให้ fill แนวตั้ง
    text.BackgroundTransparency = 1
    text.TextSize = 15
    text.TextWrapped = true
    text.TextXAlignment = Enum.TextXAlignment.Left
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Parent = ai
    return ai
end

local function plr(Text, Offset)
    Offset = tonumber(Offset) or 0
    local plrFrame = Instance.new("Frame")
    plrFrame.Name = "plr"
    plrFrame.BackgroundColor3 = Color3.fromRGB(255,255,255)
    plrFrame.BackgroundTransparency = 0.8
    plrFrame.Size = UDim2.new(0.96, 0, 0, Offset or 60) -- ระบุ height ชัดเจน
    plrFrame.Parent = Scroll
    createUIListLayout(plrFrame, 0, 10, HCenter, VCenter, SName, FillH)
    Stroke(plrFrame, ASMBorder, 255, 255, 255, LJMRound, 1, 0)
    Corner(0, 8, plrFrame)

    local image = Instance.new("ImageLabel")
    image.Name = "a2"
    image.Image = "rbxassetid://135474395711579"
    image.Size = UDim2.new(0, 50, 0, 50)
    image.BackgroundTransparency = 0.8
    image.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    image.Parent = plrFrame
    Corner(0, 8, image)
    Stroke(image, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

    local text = Instance.new("TextLabel")
    text.Name = "a1"
    text.Text = tostring(Text or "")
    text.Size = UDim2.new(0.88, -8, 1, 0)
    text.BackgroundTransparency = 1
    text.TextSize = 15
    text.TextWrapped = true
    text.TextXAlignment = Enum.TextXAlignment.Right
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Parent = plrFrame
    return plrFrame
end

-- MESSAGE
local function mesg(Text, Offset, R, G, B, R1, G1, B1)
    Offset = tonumber(Offset) or 0
    local mesge = Instance.new("Frame")
    mesge.Name = "message"
    mesge.BackgroundColor3 = Color3.fromRGB(R, G, B or 255, 255, 255)
    mesge.BackgroundTransparency = 0.8
    mesge.Size = UDim2.new(0.96, 0, 0, Offset or 60) -- ระบุ height ชัดเจน
    mesge.Parent = Scroll
    createUIListLayout(mesge, 0, 10, HCenter, VCenter, SName, FillH)
    Stroke(mesge, ASMBorder, 255, 255, 255, LJMRound, 1, 0)
    Corner(0, 8, mesge)

    local text = Instance.new("TextLabel")
    text.Name = "a1"
    text.Text = tostring(Text or "")
    text.Size = UDim2.new(0.88, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextColor3 = Color3.fromRGB(R1, G1, B1 or 0, 0, 0)
    text.TextSize = 15
    text.TextWrapped = true
    text.TextXAlignment = Enum.TextXAlignment.Center
    text.TextYAlignment = Enum.TextYAlignment.Center
    text.Parent = mesge
    return mesg
end

-- =====END FUNCTION AI AND PLAYER + END INSETFRAME=====

-- [ INPUT ]
local box = Instance.new("TextBox")
box.Name = "Ask"
box.Size = UDim2.new(0.72, 0, 0.9, 0)
box.Position = UDim2.new(0.02, 0, 0.05, 0)
box.BackgroundTransparency = 1
box.PlaceholderColor3 = Color3.fromRGB(95,95,95)
box.PlaceholderText = "Ask anything..."
box.Text = ""
box.TextScaled = true
box.TextColor3 = Color3.fromRGB(0,0,0)
box.RichText = true
box.ClearTextOnFocus = false
box.Parent = input

local send = Instance.new("TextButton")
send.Name = "Send"
send.Size = UDim2.new(0.076, 0, 0.9, 0)
send.Position = UDim2.new(0.75, 0, 0.05, 0)
send.BackgroundTransparency = 0.6
send.TextScaled = true
send.Text = "✓"
send.TextColor3 = Color3.fromRGB(0,0,0)
send.Parent = input
Corner(0, 8, send)
Stroke(send, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

local clear = Instance.new("TextButton")
clear.Name = "clear"
clear.Size = UDim2.new(0.076, 0, 0.9, 0)
clear.Position = UDim2.new(0.835, 0, 0.05, 0)
clear.BackgroundTransparency = 0.6
clear.TextScaled = true
clear.Text = "×"
clear.TextColor3 = Color3.fromRGB(0,0,0)
clear.Parent = input
Corner(0, 8, clear)
Stroke(clear, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

local rec = Instance.new("TextButton")
rec.Name = "re-chat"
rec.Size = UDim2.new(0.076, 0, 0.9, 0)
rec.Position = UDim2.new(0.918, 0, 0.05, 0)
rec.BackgroundTransparency = 0.6
rec.TextScaled = true
rec.Text = "re-chat"
rec.TextColor3 = Color3.fromRGB(0,0,0)
rec.Parent = input
Corner(0, 8, rec)
Stroke(rec, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

mesg("Verison: Alpha Dev Test", 30, 76, 76, 76, 255, 255, 255)
mesg("copyright © ExperienceSettings-ChatGPT 2025", 30, 76, 76, 76, 255, 255, 255)
ai("I'm ready to chat with you!", 60)
mesg(" --[ New Chat ]--", 30, 0, 0, 0, 255, 255, 255)
mesg("Chat is empty, Please type something!", 30, 0, 0, 0, 75, 75, 75)

local option = Instance.new("Frame")
option.Name = "a1_option"
option.Size = UDim2.new(1, 0, 0, 50)
option.BackgroundColor3 = Color3.fromRGB(255,255,255)
option.BackgroundTransparency = 1
option.Parent = insetFrame

local logo = Instance.new("Frame")
logo.Name = "a1.logo"
logo.Size = UDim2.new(0.2, 0, 0, 50)
logo.BackgroundColor3 = Color3.fromRGB(255,255,255)
logo.BackgroundTransparency = 0.6
logo.Parent = option
Corner(0, 8, logo)
Stroke(logo, ASMBorder, 255, 255, 255, LSMRound, 1, 0)

local lotext = Instance.new("TextLabel")
lotext.Name = "Text"
lotext.Size = UDim2.new(0.9, 0, 0.9, 0)
lotext.Position = UDim2.new(0.05, 0, 0.05, 0)
lotext.BackgroundTransparency = 1
lotext.Text = "LighterCyan"
lotext.TextColor3 = Color3.fromRGB(255, 255, 255)
lotext.TextStrokeTransparency = 0
lotext.TextStrokeColor3 = Color3.fromRGB(85, 255, 255)
lotext.TextScaled = true
lotext.Parent = logo

-- =====FUNCTION TEXTBUTTON=====
local function btm(Name, Text, Pos)
    local btm1 = Instance.new("Frame")
    btm1.Name = tostring(Name or "")
    btm1.BackgroundColor3 = Color3.fromRGB(255,255,255)
    btm1.BackgroundTransparency = 0.6
    btm1.Size = UDim2.new(0.1, 0, 0, 50)
    btm1.Position = UDim2.new(Pos or 0, 0, 0, 0)
    btm1.Parent = option
    Corner(0, 8, btm1)
    Stroke(btm1, ASMBorder, 255, 255, 255, LJMRound, 1, 0)

    local btm2 = Instance.new("TextButton")
    btm2.Size = UDim2.new(0.9, 0, 0.9, 0)
    btm2.Position = UDim2.new(0.05, 0, 0.05, 0)
    btm2.TextScaled = true
    btm2.BackgroundTransparency = 1
    btm2.Text = tostring(Text or "")
    btm2.Parent = btm1

    -- ใส่ Gradient ดำล้วน
    Gradient(btm2, 0, 0, 0, Color3.fromRGB(0,0,0), Color3.fromRGB(0,0,0))

    return btm1
end

btm("a2.Chat", "🗨️ Chat", 0)
btm("a3.Settings", "⚙️ Settings", 0)
btm("a4.Explorer", "🌏 Explorer", 0)
btm("a50.More", "📦 More", 0)
createUIListLayout(option, 0, 5, HLeft, VCenter, SName, FillH) -- btw Scaled 0 because UIListLayout haha, now go back to work.

-- merged_controller.lua
-- LighterCyan controller (single-file) - client only
-- Connects to Player.ai_runtime bindables (ai.DataStorage, ai.Learning, ai.Training)
-- Hooks into LighterCyan GUI (read-only) to capture user input and display Thinking/answers
-- Provides commands: /fetch, /loadstring(...), /run, /explorer, /train
-- Robust (pcall guarded), auto-resize support, and fallback behaviors.
-- Author: Generated for your LighterCyan setup
-- Usage: run in executor (KRNL) or as LocalScript after GUI present.

-- =========================
-- Config
-- =========================
local DEBUG = false -- set true to get more prints
local GUI_WAIT_TIMEOUT = 12 -- seconds to wait for LighterCyan GUI base
local THINKING_TEXT = "Thinking..."

-- =========================
-- Services
-- =========================
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local TextService = game:GetService("TextService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
if not player then
    warn("[LC.Controller] No LocalPlayer - must run as LocalScript or via executor after player exists.")
    return
end

-- safe debug print
local function dbg(...)
    if not DEBUG then return end
    local args = {...}
    local parts = {"[LC]"}
    for i=1,#args do parts[#parts+1] = tostring(args[i]) end
    pcall(function() print(table.unpack(parts)) end)
end

-- safe pcall wrapper returning ok, res
local function safe(fn, ...)
    return pcall(fn, ...)
end

-- =========================
-- Helpers for ai_runtime bindables
-- =========================
local function get_ai_runtime_folder()
    -- folder under Player created by bootstrap.lua
    local f = player:FindFirstChild("ai_runtime")
    if f then return f end
    -- sometimes scripts may create it slightly delayed
    local ok, res = pcall(function() return player:WaitForChild("ai_runtime", 2) end)
    if ok then return res end
    return nil
end

local function wait_for_bindable(name, timeout)
    local folder = get_ai_runtime_folder()
    if not folder then return nil end
    local obj = folder:FindFirstChild(name)
    if obj then return obj end
    local ok, res = pcall(function() return folder:WaitForChild(name, timeout or 3) end)
    if ok then return res end
    return folder:FindFirstChild(name)
end

-- wrappers: safe invoke/fire with pcall
local function data_add(text, meta)
    local fn = wait_for_bindable("ai.DataStorage_Add", 1)
    if fn and fn:IsA("BindableFunction") then
        local ok, res = safe(function() return fn:Invoke(text, meta) end)
        return ok, res
    end
    return false, "DataStorage_Add not available"
end

local function data_get_all()
    local fn = wait_for_bindable("ai.DataStorage_Get", 1)
    if fn and fn:IsA("BindableFunction") then
        local ok, res = safe(function() return fn:Invoke() end)
        return ok, res
    end
    return false, "DataStorage_Get not available"
end

local function fire_learning(cmd, payload)
    local ev = wait_for_bindable("ai.Learning", 1)
    if ev and ev:IsA("BindableEvent") then
        pcall(function() ev:Fire(cmd, payload) end)
        return true
    end
    return false
end

local function fire_training(cmd, payload)
    local ev = wait_for_bindable("ai.Training", 1)
    if ev and ev:IsA("BindableEvent") then
        pcall(function() ev:Fire(cmd, payload) end)
        return true
    end
    return false
end

local function predict_supervised(text)
    local folder = get_ai_runtime_folder()
    if not folder then return nil end
    local fn = folder:FindFirstChild("ai.Learning_Supervised_Predict")
    if fn and fn:IsA("BindableFunction") then
        local ok, res = safe(function() return fn:Invoke(text) end)
        if ok and res then return res end
    end
    return nil
end

local function get_unsupervised_topics(n)
    local folder = get_ai_runtime_folder()
    if not folder then return nil end
    local fn = folder:FindFirstChild("ai.Unsupervised_GetTopics")
    if fn and fn:IsA("BindableFunction") then
        local ok, res = safe(function() return fn:Invoke(n) end)
        if ok then return res end
    end
    return nil
end

local function overfit_check(epoch)
    local folder = get_ai_runtime_folder()
    if not folder then return nil end
    local fn = folder:FindFirstChild("ai.Overfit_Check")
    if fn and fn:IsA("BindableFunction") then
        local ok, res = safe(function() return fn:Invoke(epoch) end)
        if ok then return res end
    end
    return nil
end

-- =========================
-- GUI resolution (read-only)
-- =========================
local function get_lightercyan_inset()
    -- try to safely access path: CoreGui.TopBarApp.TopBarApp.UnibarLeftFrame.HealthBar.ExperienceSettings["LighterCyan.ai"].Holder.InsetFrame
    local ok, base = pcall(function()
        local t = CoreGui.TopBarApp
        if not t then return nil end
        t = t.TopBarApp
        if not t then return nil end
        t = t.UnibarLeftFrame
        if not t then return nil end
        t = t.HealthBar
        if not t then return nil end
        t = t.ExperienceSettings
        if not t then return nil end
        t = t["LighterCyan.ai"]
        if not t then return nil end
        t = t.Holder
        if not t then return nil end
        t = t.InsetFrame
        return t
    end)
    if ok then return base end
    return nil
end

-- wait for GUI base with timeout
local function wait_for_gui(timeout)
    timeout = timeout or GUI_WAIT_TIMEOUT
    local t0 = tick()
    repeat
        local inset = get_lightercyan_inset()
        if inset then return inset end
        task.wait(0.08)
    until tick() - t0 > timeout
    return nil
end

-- =========================
-- Scroll/UI helpers
-- =========================
local function find_scroll_frame()
    local inset = get_lightercyan_inset()
    if not inset then return nil end
    local chat = inset:FindFirstChild("a2_Chat")
    if not chat then
        -- sometimes chat nested differently; attempt to find descendant named Chat
        for _,v in ipairs(inset:GetDescendants()) do
            if v.Name == "Chat" and v:IsA("ScrollingFrame") then
                chat = v; break
            end
        end
    end
    local scroll = chat and chat:FindFirstChild("Chat") or chat -- if double-named
    if scroll and scroll:IsA("ScrollingFrame") then return scroll end
    if chat and chat:IsA("ScrollingFrame") then return chat end
    return nil
end

-- update canvas & autoscroll to bottom
local function update_canvas(scroll)
    if not scroll or not scroll:IsA("ScrollingFrame") then return end
    local layout = scroll:FindFirstChildOfClass("UIListLayout")
    if not layout then return end
    task.defer(function()
        local ok, size = pcall(function() return layout.AbsoluteContentSize end)
        if ok and size then
            pcall(function()
                scroll.CanvasSize = UDim2.new(0,0,0, math.max(size.Y + 8, scroll.AbsoluteSize.Y))
                scroll.CanvasPosition = Vector2.new(0, math.max(0, size.Y - scroll.AbsoluteSize.Y))
            end)
        end
    end)
end

-- find latest a2 text for context
local function read_latest_a2(scroll)
    if not scroll then return nil end
    local chs = scroll:GetChildren()
    for i = #chs, 1, -1 do
        local c = chs[i]
        for _,d in ipairs(c:GetDescendants()) do
            if d:IsA("TextLabel") and d.Name == "a2" then
                return tostring(d.Text)
            end
        end
    end
    return nil
end

-- create fallback AI frame (if ai() not available)
local function create_ai_frame(scroll, text)
    if not scroll then return nil end
    local f = Instance.new("Frame")
    f.Size = UDim2.new(0.96,0,0,40)
    f.BackgroundTransparency = 1
    f.Parent = scroll
    local icon = Instance.new("ImageLabel")
    icon.Name = "a1"
    icon.Size = UDim2.new(0,44,0,44)
    icon.Position = UDim2.new(0,6,0,-2)
    icon.BackgroundTransparency = 1
    icon.Parent = f
    local lbl = Instance.new("TextLabel")
    lbl.Name = "a2"
    lbl.Text = tostring(text or "")
    lbl.TextWrapped = true
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.BackgroundTransparency = 1
    lbl.Size = UDim2.new(0.88,-8,1,-12)
    lbl.Position = UDim2.new(0,56,0,6)
    lbl.Parent = f
    pcall(function() lbl.AutomaticSize = Enum.AutomaticSize.Y end)
    task.wait(0.01)
    pcall(function() if lbl.AutomaticSize then f.Size = UDim2.new(0.96,0,0, lbl.AbsoluteSize.Y + 12) end end)
    update_canvas(scroll)
    return f
end

-- replace thinking frame text safely
local function replace_thinking_frame_text(thinkingFrame, text)
    if thinkingFrame and thinkingFrame.Parent then
        pcall(function()
            for _,d in ipairs(thinkingFrame:GetDescendants()) do
                if d:IsA("TextLabel") and d.Name == "a2" then
                    d.Text = tostring(text or "")
                end
            end
        end)
        -- try to adjust size
        pcall(function() local lbl = thinkingFrame:FindFirstChildWhichIsA("TextLabel", true); end)
        -- trigger canvas update
        local sc = find_scroll_frame()
        update_canvas(sc)
        return true
    else
        -- fallback: call global ai if available, else create frame
        if type(ai) == "function" then pcall(ai, text, 60) else
            local sc = find_scroll_frame()
            create_ai_frame(sc, text)
        end
    end
end

-- showThinking: returns frame (if created or located) for later replace
local function show_thinking_and_get_frame()
    local thinkingFrame = nil
    -- prefer existing ai function
    if type(ai) == "function" then
        safe(function() ai(THINKING_TEXT, 60) end)
        -- try to find frame with TEXT == "Thinking..."
        local sc = find_scroll_frame()
        if sc then
            for i = #sc:GetChildren(), 1, -1 do
                local c = sc:GetChildren()[i]
                if c then
                    for _,d in ipairs(c:GetDescendants()) do
                        if d:IsA("TextLabel") and d.Name == "a2" and d.Text == THINKING_TEXT then
                            thinkingFrame = c; break
                        end
                    end
                    if thinkingFrame then break end
                end
            end
        end
    end
    if not thinkingFrame then
        thinkingFrame = create_ai_frame(find_scroll_frame(), THINKING_TEXT)
    end
    return thinkingFrame
end

-- =========================
-- Local corpus: cache from DataStorage for fallback matching
-- =========================
local LocalCorpus = { en = {}, th = {}, ext = {} }
local function detect_lang(s)
    if not s then return "en" end
    if tostring(s):find("[%z\194-\244][\128-\191]") then
        -- crude UTF detection, but fallback to checking Thai characters
    end
    if tostring(s):find("[ก-๙]") then return "th" end
    return "en"
end

local function add_to_local_corpus(lang, text)
    if not text or tostring(text):match("^%s*$") then return end
    lang = lang or detect_lang(text)
    LocalCorpus[lang] = LocalCorpus[lang] or {}
    table.insert(LocalCorpus[lang], tostring(text))
end

local function rebuild_local_from_storage()
    local ok, res = data_get_all()
    if not ok or not res then
        dbg("rebuild_local_from_storage failed:", res)
        return false
    end
    -- res may be {examplesTable, stats} depending on implementation
    local examples = res[1] or res
    LocalCorpus = { en = {}, th = {}, ext = {} }
    for _,ex in ipairs(examples) do
        local txt = tostring(ex.text or ex)
        local lang = detect_lang(txt)
        add_to_local_corpus(lang, txt)
    end
    dbg("LocalCorpus rebuilt with", (LocalCorpus.en and #LocalCorpus.en or 0), "en and", (LocalCorpus.th and #LocalCorpus.th or 0), "th")
    return true
end

-- local fuzzy match (token intersection)
local function simple_local_match(input, context, lang)
    input = tostring(input or ""):lower()
    context = tostring(context or ""):lower()
    lang = lang or detect_lang(input)
    local tokens = {}
    for w in input:gmatch("%w+") do if #w >= 3 then tokens[#tokens+1] = w end end
    for _,txt in ipairs(LocalCorpus[lang] or {}) do
        local score = 0
        local lower = tostring(txt):lower()
        for _,t in ipairs(tokens) do
            if lower:find(t, 1, true) then score = score + 1 end
        end
        if score > 0 then
            return txt -- return first reasonable match (could be improved)
        end
    end
    -- try ext corpus
    for _,txt in ipairs(LocalCorpus.ext or {}) do
        local score = 0
        local lower = tostring(txt):lower()
        for _,t in ipairs(tokens) do if lower:find(t,1,true) then score = score + 1 end end
        if score > 0 then return txt end
    end
    return nil
end

-- =========================
-- Think pipeline: supervised predict -> unsupervised topics -> local match -> fallback reply
-- Avoid repetitive "I'm thinking" by producing meaningful answers
-- =========================
local function compute_answer(input, context)
    local lang = detect_lang(input or context)
    -- 1) supervised model prediction
    local pred = nil
    pred = predict_supervised(input)
    if pred and tostring(pred) ~= "" then
        dbg("predict_supervised hit")
        return tostring(pred)
    end

    -- 2) unsupervised topics (try to give summary using top topics)
    local topics = get_unsupervised_topics(5)
    if topics and #topics > 0 then
        -- simple short summary: return top 1-2 topics
        local top = topics[1] and (topics[1].w or topics[1].w)
        if top then
            if lang == "th" then
                return "จากข้อมูลที่มี ดูเหมือนว่าหัวข้อสำคัญคือ: " .. tostring(top)
            else
                return "Based on gathered data, main topic seems to be: " .. tostring(top)
            end
        end
    end

    -- 3) local corpus fuzzy match
    local match = simple_local_match(input, context, lang)
    if match then
        if lang == "th" then return "ฉันพบบทความที่เกี่ยวข้อง: " .. match:sub(1,300) end
        return "I found something related: " .. match:sub(1,300)
    end

    -- 4) fallback template answer (not repetitive)
    if lang == "th" then
        return "ขอโทษครับ ผมยังหาอะไรที่ตรงประเด็นไม่เจอ — ลองให้ข้อมูลเพิ่มหรือใช้ /fetch <url> เพื่อดึงข้อมูลภายนอก"
    else
        return "Sorry, I couldn't find a focused answer — try adding more context or use /fetch <url> to pull external data."
    end
end

-- ThinkAsync: show Thinking..., compute answer off-main, then replace/append
local function ThinkAsync(input, context)
    local thinkingFrame = safe(function() return show_thinking_and_get_frame() end)
    -- compute off-main thread
    task.spawn(function()
        -- small deliberate delay to allow "Thinking..." to appear
        task.wait(0.06)
        -- ensure local corpus updated (lightweight)
        pcall(rebuild_local_from_storage)
        local ok, ans = pcall(function() return compute_answer(input, context) end)
        if not ok or not ans then
            ans = (detect_lang(input) == "th") and "เกิดข้อผิดพลาดในการประมวลผลคำตอบ" or "Error computing answer"
            dbg("compute_answer error:", ans)
        end
        pcall(function() replace_thinking_frame_text(thinkingFrame, ans) end)
    end)
end

-- =========================
-- Command handling
-- supports:
--   /fetch <url>
--   /loadstring(<code>)  (runs code; VERY DANGEROUS: user must trust source)
--   /run <code> (RunExplorer)
--   /explorer <code>
--   /train <mode> or /train.start {params} /train.stop
--   /help
-- =========================
local function run_code_string(code)
    -- safe wrapper for loadstring/load
    if not code or code == "" then return false, "empty" end
    if type(loadstring) == "function" then
        local ok, fn = pcall(function() return loadstring(code) end)
        if not ok then return false, fn end
        if type(fn) == "function" then
            local ok2, res = pcall(fn)
            return ok2, res
        end
        return false, "no function"
    elseif type(load) == "function" then
        local fn, err = load(code)
        if not fn then return false, err end
        local ok2, res = pcall(fn)
        return ok2, res
    else
        return false, "no load available"
    end
end

local function handle_fetch(url)
    if not url or url == "" then
        local err = "empty url"
        pcall(function() if type(ai)=="function" then ai("Fetch error: "..err,60) else create_ai_frame(find_scroll_frame(), "Fetch error: "..err) end end)
        return
    end
    -- show thinking
    local thinkingFrame = show_thinking_and_get_frame()
    task.spawn(function()
        local ok, res = pcall(function() return game:HttpGet(url) end)
        if not ok or not res then
            -- try HttpService:GetAsync
            ok, res = pcall(function() return HttpService:GetAsync(url, true) end)
        end
        if not ok or not res then
            local err = tostring(res or "fetch failed")
            pcall(function() replace_thinking_frame_text(thinkingFrame, "Fetch error: "..err) end)
            return
        end
        -- add to DataStorage ext & rebuild local corpus
        pcall(function() data_add(res, {source="fetch", time=os.time()}) end)
        pcall(rebuild_local_from_storage)
        -- compute answer with fetched content as context
        local ans = compute_answer("", tostring(res):sub(1,2000))
        pcall(function() replace_thinking_frame_text(thinkingFrame, ans) end)
    end)
end

local function handle_loadstring(cmdtext)
    -- cmdtext may be "loadstring(...)" or full code; we try to run it robustly
    local ok, res = run_code_string(cmdtext)
    if ok then
        pcall(function() if type(ai)=="function" then ai(tostring(res or "Executed"), 60) else create_ai_frame(find_scroll_frame(), tostring(res or "Executed")) end end)
    else
        pcall(function() if type(ai)=="function" then ai("Error: "..tostring(res),60) else create_ai_frame(find_scroll_frame(), "Error: "..tostring(res)) end end)
    end
end

local function handle_run(code)
    local ok, res = run_code_string(code)
    if ok then pcall(function() if type(ai)=="function" then ai(tostring(res or "Executed"),60) else create_ai_frame(find_scroll_frame(), tostring(res or "Executed")) end end)
    else pcall(function() if type(ai)=="function" then ai("Run error: "..tostring(res),60) else create_ai_frame(find_scroll_frame(), "Run error: "..tostring(res)) end end) end
end

-- main command dispatcher
local function handle_command_or_text(inputText)
    if not inputText then return end
    inputText = tostring(inputText):match("^%s*(.-)%s*$")
    if inputText == "" then return end

    -- slash commands
    if inputText:sub(1,1) == "/" then
        local body = inputText:sub(2)
        -- /help
        if body:match("^help") then
            local help = [[Commands:
            /fetch <url>       -> fetch content and use as context
            /loadstring <...>  -> run code chunk (dangerous)
            /run <code>        -> run short code
            /train start {...} -> start training job (uses ai.Training)
            /train stop        -> stop training
            /train <mode>      -> fire ai.Learning with mode
            /explorer <code>   -> alias for /run
            ]]
            pcall(function() if type(ai)=="function" then ai(help,60) else create_ai_frame(find_scroll_frame(), help) end end)
            return
        end

        -- /fetch url
        local furl = body:match("^fetch%s+(.+)$")
        if furl or body:match("^https?://") then
            handle_fetch(furl or body)
            return
        end

        -- /loadstring <...> or startswith loadstring(
        if body:match("^%s*loadstring") or body:match("^%s*%(") or body:match("^%s*eval") then
            -- try to get the code part (body itself)
            handle_loadstring(body)
            return
        end

        -- /run or /explorer
        local runcode = body:match("^run%s+(.+)$") or body:match("^explorer%s+(.+)$")
        if runcode then
            handle_run(runcode)
            return
        end

        -- /train commands
        local tr = body:match("^train%s*(.*)$")
        if tr then
            -- if empty -> show help
            if tr == "" then
                pcall(function() if type(ai)=="function" then ai("Train usage: /train start/stop or /train <mode>",60) else create_ai_frame(find_scroll_frame(), "Train usage: /train start/stop or /train <mode>") end end)
                return
            end
            -- /train start {json-like} or /train stop
            if tr:match("^start") then
                -- attempt to parse params after start (naive)
                local params_str = tr:match("^start%s*(.+)$") or ""
                local params = {}
                -- very light parser for "mode=supervised,epochs=5,batchSize=16"
                for k,v in params_str:gmatch("(%w+)%s*=%s*([^,%s]+)") do
                    if tonumber(v) then v = tonumber(v) end
                    params[k] = v
                end
                if not params.mode then params.mode = "supervised" end
                fire_training("start", params)
                pcall(function() if type(ai)=="function" then ai("Training started: "..tostring(params.mode),60) else create_ai_frame(find_scroll_frame(), "Training started: "..tostring(params.mode)) end end)
                return
            elseif tr:match("^stop") then
                fire_training("stop")
                pcall(function() if type(ai)=="function" then ai("Training stop requested",60) else create_ai_frame(find_scroll_frame(), "Training stop requested") end end)
                return
            else
                -- /train <mode> : forward to ai.Learning
                fire_learning(tr)
                pcall(function() if type(ai)=="function" then ai("Learning command fired: "..tostring(tr),60) else create_ai_frame(find_scroll_frame(), "Learning command: "..tostring(tr)) end end)
                return
            end
        end

        -- unknown slash: fallback: run as code?
        pcall(function() if type(ai)=="function" then ai("Unknown command. Use /help",60) else create_ai_frame(find_scroll_frame(), "Unknown command. Use /help") end end)
        return
    end

    -- Normal text flow:
    -- 1) store into DataStorage
    local ok, res = data_add(inputText, {source="gui", time=os.time()})
    if not ok then dbg("data_add failed:", res) end
    -- 2) quick local train trigger (lightweight)
    pcall(function() fire_learning("train_supervised") end)
    -- 3) compute context
    local sc = find_scroll_frame()
    local latest = read_latest_a2(sc) or ""
    -- 4) show thinking & compute answer
    ThinkAsync(inputText, latest)
end

-- =========================
-- Hook GUI: capture Send button and AskBox.FocusLost
-- Do not modify original GUI structure (read-only)
-- =========================
local function hook_gui_handlers()
    local inset = wait_for_gui(GUI_WAIT_TIMEOUT)
    if not inset then warn("[LC.Controller] LighterCyan GUI not found; GUI hooks disabled.") return false end
    local inputFrame = inset:FindFirstChild("a3_Input&Send")
    if not inputFrame then
        -- try find descendant
        for _,v in ipairs(inset:GetDescendants()) do if v.Name == "a3_Input&Send" and v:IsA("Frame") then inputFrame = v; break end end
    end
    if not inputFrame then warn("[LC.Controller] input frame not found in inset") return false end
    local AskBox = inputFrame:FindFirstChild("Ask")
    local SendBtn = inputFrame:FindFirstChild("Send")
    local ClearBtn = inputFrame:FindFirstChild("clear")
    local RecBtn = inputFrame:FindFirstChild("re-chat") or inputFrame:FindFirstChild("rec")

    -- safe connect helper
    local function safe_connect_mouse(btn, fn)
        if not btn then return end
        pcall(function()
            if typeof(btn.MouseButton1Click) == "RBXScriptSignal" then
                btn.MouseButton1Click:Connect(fn)
            end
        end)
    end

    -- Send button
    safe_connect_mouse(SendBtn, function()
        local txt = nil
        pcall(function() if AskBox and AskBox:IsA("TextBox") then txt = AskBox.Text end end)
        if txt and tostring(txt):match("%S") then
            handle_command_or_text(txt)
            pcall(function() if AskBox then AskBox.Text = "" end end)
        end
    end)

    -- Clear button (clear AskBox text)
    safe_connect_mouse(ClearBtn, function()
        pcall(function() if AskBox and AskBox:IsA("TextBox") then AskBox.Text = "" end end)
    end)

    -- Rec button: clear Scroll child frames
    safe_connect_mouse(RecBtn, function()
        local sc = find_scroll_frame()
        if sc then
            pcall(function()
                for _,c in ipairs(sc:GetChildren()) do if c:IsA("Frame") then pcall(function() c:Destroy() end) end end
            end)
            update_canvas(sc)
        end
    end)

    -- Enter (FocusLost)
    if AskBox and AskBox:IsA("TextBox") then
        pcall(function()
            AskBox.FocusLost:Connect(function(enter)
                if enter then
                    local t = AskBox.Text or ""
                    if t and t:match("%S") then
                        handle_command_or_text(t)
                        pcall(function() AskBox.Text = "" end)
                    end
                end
            end)
        end)
    end

    dbg("GUI hooks installed")
    return true
end

-- rehook loop: if GUI reloads, re-hook handlers
task.spawn(function()
    while task.wait(2) do
        local inset = get_lightercyan_inset()
        if not inset then
            -- GUI possibly closed; wait next loop
        else
            -- check if hooks already installed by simple marker (we won't modify GUI)
            -- we attempt to re-hook every cycle (safe_connect prevents double connects causing issues)
            hook_gui_handlers()
            -- small delay so we don't hammer
            task.wait(4)
        end
    end
end)

-- =========================
-- Expose a small local API for quick testing via console
-- =========================
local function expose_api()
    local folder = get_ai_runtime_folder() or Instance.new("Folder", player)
    if not folder.Parent then folder.Name = "ai_runtime"; folder.Parent = player end
    local ctl = folder:FindFirstChild("__LC_Controller_API")
    if ctl then pcall(function() ctl:Destroy() end) end
    local fn = Instance.new("BindableFunction")
    fn.Name = "__LC_Controller_API"
    fn.Parent = folder
    fn.OnInvoke = function(cmd, arg)
        cmd = tostring(cmd or "")
        if cmd == "rebuild_local" then
            return pcall(rebuild_local_from_storage)
        elseif cmd == "test_predict" then
            return pcall(predict_supervised, tostring(arg or ""))
        elseif cmd == "train_start" then
            return pcall(function() fire_training("start", arg or {mode="supervised", epochs=3}) end)
        elseif cmd == "list_bindables" then
            local t = {}
            for _,c in ipairs(folder:GetChildren()) do t[#t+1] = c.Name .. ":" .. c.ClassName end
            return true, t
        end
        return false, "unknown cmd"
    end
    dbg("Controller API exposed at ai_runtime.__LC_Controller_API")
end

-- =========================
-- Initialization
-- =========================
-- initial rebuild local corpus (best-effort)
pcall(rebuild_local_from_storage)

-- Try to hook GUI once immediately
hook_gui_handlers()

-- expose API for quick console control
expose_api()

print("[LC.Controller] Ready. GUI hooks active (if GUI present). Use console to call functions or type in GUI.")
