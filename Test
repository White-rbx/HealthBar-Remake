-- ChatGPT Full LocalScript for ExperienceSettings (Client)
-- Features:
--  - Uses existing 'gpt' toggle button if present (a3_ChatGPT)
--  - gptGui width = 0.4, OFF = -0.4 X, ON = 0 X
--  - Chat messages will be clipped (TextClipped) and won't resize frame
--  - Commands: /API, /APIJ, /Help, /ClearTexts, /Instance, /Resize, /Position, /Color, /InstanceMesh, /InstanceSurfaceGui, /SeeChat, /UnSeeChat, /View, /StopView, /CheckPlaHP, /CheckPlaAround, /Deaths, /Keep, /HttpService, /HttpEnabled, /loadstring
--  - Robust: pcall, guards, forward-declare support

-- ===== Services =====
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then warn("[ChatGPT] LocalScript requires LocalPlayer") return end

-- ===== Helpers =====
local function trim(s) return (tostring(s or ""):gsub("^%s+", ""):gsub("%s+$", "")) end
local function redactKey(k)
    if type(k) ~= "string" then return "<nil>" end
    if #k <= 12 then return "********" end
    return k:sub(1,6) .. "..." .. k:sub(-6)
end
local function safeTween(obj, props, time, style, dir)
    if not obj or not obj.Parent then return end
    pcall(function()
        local info = TweenInfo.new(time or 0.28, style or Enum.EasingStyle.Quad, dir or Enum.EasingDirection.Out)
        local tw = TweenService:Create(obj, info, props or {})
        tw:Play()
    end)
end
local function isHttpEnabled()
    local ok, val = pcall(function() return HttpService and HttpService.HttpEnabled end)
    return ok and val
end

-- ===== State =====
local STATE = {
    OPENAI_KEY = nil,
    PROJECT_ID = nil,
    MODEL = "gpt-3.5-turbo",
    validated = false,
    requestInFlight = false
}

-- ===== Resolve root GUI (menuGui/expSettings/healthBar/gethui/CoreGui/PlayerGui) =====
local rootGui = nil
if typeof(menuGui) == "Instance" and menuGui.Parent then rootGui = menuGui
elseif typeof(expSettings) == "Instance" and expSettings.Parent then rootGui = expSettings
elseif typeof(healthBar) == "Instance" and healthBar.Parent then rootGui = healthBar
else
    local ok, gethui = pcall(function() return gethui end)
    if ok and type(gethui) == "function" then
        local suc, gh = pcall(gethui)
        if suc and gh and typeof(gh) == "Instance" then rootGui = gh end
    end
    if not rootGui then
        local core = game:GetService("CoreGui")
        if core and core.Parent then rootGui = core end
    end
    if not rootGui then
        local pg = LocalPlayer:FindFirstChild("PlayerGui")
        if pg then
            local sg = pg:FindFirstChild("ExperienceSettings_ChatGPT_SG")
            if not sg then
                sg = Instance.new("ScreenGui"); sg.Name = "ExperienceSettings_ChatGPT_SG"; sg.ResetOnSpawn = false; sg.Parent = pg
            end
            rootGui = sg
        end
    end
end

if not rootGui then warn("[ChatGPT] No GUI root found, aborting") return end

-- ===== Try find existing toggle (gpt) =====
local toggleButton = nil
if typeof(gpt) == "Instance" and (gpt:IsA("ImageButton") or gpt:IsA("TextButton")) then
    toggleButton = gpt
else
    toggleButton = rootGui:FindFirstChild("a3_ChatGPT", true) or rootGui:FindFirstChild("gpt", true)
    if toggleButton and not (toggleButton:IsA("ImageButton") or toggleButton:IsA("TextButton")) then toggleButton = nil end
end

-- ===== Build/Reuse gptGui panel =====
local PANEL_NAME = "a3_ChatGPT_Panel"
local panel = rootGui:FindFirstChild(PANEL_NAME, true)
if not panel then
    panel = Instance.new("Frame")
    panel.Name = PANEL_NAME
    panel.Size = UDim2.new(0.4, 0, 0.9, 0) -- width 0.4
    panel.Position = UDim2.new(-0.4, 0, 0.05, 0) -- OFF
    panel.BackgroundColor3 = Color3.fromRGB(18,18,20)
    panel.BackgroundTransparency = 0.12
    panel.Parent = rootGui
    local corner = Instance.new("UICorner"); corner.Parent = panel
end

local back = panel:FindFirstChild("Background")
if not back then
    back = Instance.new("Frame")
    back.Name = "Background"
    back.Size = UDim2.new(0.96,0,0.96,0)
    back.Position = UDim2.new(0.02,0,0.02,0)
    back.BackgroundTransparency = 1
    back.Parent = panel
end

-- top rows container (API/project)
local topRows = back:FindFirstChild("TopRows")
if not topRows then
    topRows = Instance.new("Frame")
    topRows.Name = "TopRows"
    topRows.Size = UDim2.new(1,0,0,76)
    topRows.BackgroundTransparency = 1
    topRows.Parent = back
end

-- chat scroll
local gptScroll = back:FindFirstChild("a0_Scroll")
if not gptScroll then
    gptScroll = Instance.new("ScrollingFrame")
    gptScroll.Name = "a0_Scroll"
    gptScroll.Size = UDim2.new(1,0,0.62,0)
    gptScroll.Position = UDim2.new(0,0,0.18,0)
    gptScroll.BackgroundTransparency = 0.5
    gptScroll.BackgroundColor3 = Color3.fromRGB(12,12,12)
    gptScroll.ScrollBarThickness = 6
    gptScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    gptScroll.Parent = back
    local corner = Instance.new("UICorner"); corner.Parent = gptScroll
end

local gptChat = gptScroll:FindFirstChild("Chat")
if not gptChat then
    gptChat = Instance.new("Frame")
    gptChat.Name = "Chat"
    gptChat.Size = UDim2.new(0.96,0,0,0)
    gptChat.Position = UDim2.new(0.02,0,0,10)
    gptChat.BackgroundTransparency = 1
    gptChat.Parent = gptScroll
end

-- ensure UIListLayout for ordering
local uiLayout = gptChat:FindFirstChildOfClass("UIListLayout")
if not uiLayout then
    uiLayout = Instance.new("UIListLayout")
    uiLayout.SortOrder = Enum.SortOrder.LayoutOrder
    uiLayout.Padding = UDim.new(0,6)
    uiLayout.Parent = gptChat
end
uiLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    pcall(function()
        gptScroll.CanvasSize = UDim2.new(0,0,0,uiLayout.AbsoluteContentSize.Y)
        gptScroll.CanvasPosition = Vector2.new(0, math.max(0, uiLayout.AbsoluteContentSize.Y))
    end)
end)

-- bottom input
local inputFrame = panel:FindFirstChild("a_chat_input")
if not inputFrame then
    inputFrame = Instance.new("Frame")
    inputFrame.Name = "a_chat_input"
    inputFrame.Size = UDim2.new(1,0,0,44)
    inputFrame.Position = UDim2.new(0,0,0.82,0)
    inputFrame.BackgroundTransparency = 1
    inputFrame.Parent = panel
end

local chatBox = inputFrame:FindFirstChild("ChatBox")
if not chatBox then
    chatBox = Instance.new("TextBox")
    chatBox.Name = "ChatBox"
    chatBox.Size = UDim2.new(0.75, -8, 1, 0)
    chatBox.Position = UDim2.new(0,6,0,0)
    chatBox.PlaceholderText = "Ask anything... (use / for commands)"
    chatBox.ClearTextOnFocus = false
    chatBox.Font = Enum.Font.SourceSans
    chatBox.TextSize = 16
    chatBox.BackgroundColor3 = Color3.fromRGB(255,255,255)
    chatBox.TextColor3 = Color3.fromRGB(0,0,0)
    chatBox.Parent = inputFrame
end

local sendBtn = inputFrame:FindFirstChild("SendBtn")
if not sendBtn then
    sendBtn = Instance.new("TextButton")
    sendBtn.Name = "SendBtn"
    sendBtn.Size = UDim2.new(0.25, -8, 1, 0)
    sendBtn.Position = UDim2.new(0.75, 4, 0, 0)
    sendBtn.Text = "Send"
    sendBtn.TextScaled = true
    sendBtn.BackgroundColor3 = Color3.fromRGB(86,170,255)
    sendBtn.TextColor3 = Color3.fromRGB(255,255,255)
    sendBtn.Parent = inputFrame
end

-- top-row helper (create simple row)
local function makeTopRow(parent, id, placeholder, btnText, y)
    local f = parent:FindFirstChild(id .. "_frame")
    if f then
        return f, f:FindFirstChild(id .. "_box"), f:FindFirstChild(id .. "_btn")
    end
    f = Instance.new("Frame"); f.Name = id .. "_frame"; f.Size = UDim2.new(1,0,0,36); f.Position = UDim2.new(0,0,0,y or 0); f.BackgroundTransparency = 1; f.Parent = parent
    local box = Instance.new("TextBox"); box.Name = id .. "_box"; box.Size = UDim2.new(0.75,0,1,0); box.PlaceholderText = placeholder; box.ClearTextOnFocus = false; box.Font = Enum.Font.SourceSans; box.TextSize = 16; box.BackgroundColor3 = Color3.fromRGB(40,40,40); box.TextColor3 = Color3.fromRGB(255,255,255); box.Parent = f
    local btn = Instance.new("TextButton"); btn.Name = id .. "_btn"; btn.Size = UDim2.new(0.25,0,1,0); btn.Position = UDim2.new(0.75,0,0,0); btn.Text = btnText; btn.TextScaled = true; btn.BackgroundColor3 = Color3.fromRGB(86,170,255); btn.TextColor3 = Color3.fromRGB(255,255,255); btn.Parent = f
    return f, box, btn
end

local projFrame, projBox, projBtn = makeTopRow(topRows, "a_proj_input", "Enter Project ID (proj_...)", "Next", 4)
local apiFrame, apiBox, apiBtn = makeTopRow(topRows, "a_api_input", "Enter API key (sk-...)", "Save", 40)
apiFrame.Visible = false

-- ===== appendChat (must be defined before sendChat) =====
local chatCounter = 0
_G = _G or {}

local function makeFallbackChatContainer()
    local pg = LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui")
    if not pg then return nil end
    local sg = pg:FindFirstChild("ExperienceSettings_ChatGPT_Fallback")
    if not sg then
        sg = Instance.new("ScreenGui"); sg.Name = "ExperienceSettings_ChatGPT_Fallback"; sg.ResetOnSpawn = false; sg.Parent = pg
    end
    local frame = sg:FindFirstChild("gptChat_Fallback")
    if not frame then
        frame = Instance.new("Frame")
        frame.Name = "gptChat_Fallback"
        frame.Size = UDim2.new(0.6, 0, 0.5, 0)
        frame.Position = UDim2.new(0.2,0,0.25,0)
        frame.BackgroundTransparency = 0.6
        frame.BackgroundColor3 = Color3.fromRGB(10,10,10)
        frame.Parent = sg
        local list = Instance.new("UIListLayout"); list.Parent = frame; list.SortOrder = Enum.SortOrder.LayoutOrder; list.Padding = UDim.new(0,6)
    end
    return frame
end

local function safeCreateLabel(parent, txt, isUser, colorTbl)
    local lbl
    local ok, err = pcall(function()
        lbl = Instance.new("TextLabel")
        lbl.Name = "ChatLabel"
        lbl.Size = UDim2.new(1, -12, 1, 0)
        lbl.Position = UDim2.new(0, 8, 0, 0)
        lbl.BackgroundTransparency = 1
        lbl.TextWrapped = false
        lbl.TextClipped = true
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.TextYAlignment = Enum.TextYAlignment.Center
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 18
        lbl.RichText = false
        lbl.AutoLocalize = false
        lbl.Text = tostring(txt or "")
        if colorTbl and type(colorTbl) == "table" and #colorTbl >= 3 then
            lbl.TextColor3 = Color3.fromRGB(colorTbl[1], colorTbl[2], colorTbl[3])
        else
            if isUser then lbl.TextColor3 = Color3.fromRGB(86,170,255) else lbl.TextColor3 = Color3.fromRGB(255,255,255) end
        end
        lbl.TextTransparency = 0
        lbl.Visible = true
        lbl.Parent = parent
    end)
    if not ok or not lbl or not lbl.Parent then
        local tb
        local ok2, err2 = pcall(function()
            tb = Instance.new("TextBox")
            tb.Name = "ChatLabel_Fallback"
            tb.Size = UDim2.new(1, -12, 1, 0)
            tb.Position = UDim2.new(0, 8, 0, 0)
            tb.BackgroundTransparency = 1
            tb.TextWrapped = false
            tb.TextClipped = true
            tb.TextXAlignment = Enum.TextXAlignment.Left
            tb.TextYAlignment = Enum.TextYAlignment.Center
            tb.Font = Enum.Font.SourceSans
            tb.TextSize = 18
            tb.ClearTextOnFocus = false
            tb.Text = tostring(txt or "")
            tb.ReadOnly = true
            if colorTbl and type(colorTbl) == "table" and #colorTbl >= 3 then
                tb.TextColor3 = Color3.fromRGB(colorTbl[1], colorTbl[2], colorTbl[3])
            else
                if isUser then tb.TextColor3 = Color3.fromRGB(86,170,255) else tb.TextColor3 = Color3.fromRGB(255,255,255) end
            end
            tb.Parent = parent
        end)
        if not ok2 then
            warn("[ChatGPT] Failed to create both TextLabel and fallback TextBox:", err, err2)
        end
        return tb or lbl, (not ok and err) or (not ok2 and err2)
    end
    return lbl, nil
end

local function appendChat(isUser, text, colorTbl)
    if not gptChat or typeof(gptChat) ~= "Instance" or not gptChat.Parent then
        local fb = makeFallbackChatContainer()
        if fb then
            if not fb:FindFirstChild("Chat") then
                local f = Instance.new("Frame"); f.Name = "Chat"; f.BackgroundTransparency = 1; f.Size = UDim2.new(1,0,0,0); f.Parent = fb
                local l = Instance.new("UIListLayout"); l.Parent = f; l.SortOrder = Enum.SortOrder.LayoutOrder; l.Padding = UDim.new(0,6)
                gptChat = f
            else
                gptChat = fb:FindFirstChild("Chat")
            end
        else
            warn("[ChatGPT] gptChat not present and fallback failed. Aborting appendChat.")
            return nil, "no_container"
        end
    end

    chatCounter = (chatCounter or 0) + 1
    local ok, err = pcall(function()
        local fr = Instance.new("Frame")
        fr.Name = "ChatItem_" .. tostring(chatCounter)
        fr.BackgroundTransparency = 1
        fr.Size = UDim2.new(1, 0, 0, 36)
        fr.LayoutOrder = chatCounter
        fr.Parent = gptChat

        local lbl, lerr = safeCreateLabel(fr, text, isUser, colorTbl)
        if not lbl then warn("[ChatGPT] safeCreateLabel failed:", tostring(lerr)) end
    end)
    if not ok then
        warn("[ChatGPT] appendChat failed:", tostring(err))
        return nil, err
    end

    pcall(function()
        if uiLayout and uiLayout.AbsoluteContentSize and gptScroll then
            local y = uiLayout.AbsoluteContentSize.Y
            gptScroll.CanvasSize = UDim2.new(0,0,0,y)
            gptScroll.CanvasPosition = Vector2.new(0, math.max(0, y))
        end
    end)
    return true, nil
end

_G.ChatGPT_appendChat = appendChat

local function appendSystem(t) appendChat(false, "[System] " .. tostring(t), {255,255,255}) end
local function appendError(t) appendChat(false, "[Error] " .. tostring(t), {255,80,80}) end

-- ===== helpers: parse args, locate, vector, color, mesh =====
local function stripQuotes(s) if not s then return s end s = tostring(s) s = s:gsub("^%s*\"", ""):gsub("\"%s*$", "") s = s:gsub("^%s*'", ""):gsub("'%s*$", "") return s end
local function parseParenArgs(s)
    local inside = s:match("%((.*)%)")
    if not inside then return {} end
    local parts = {}
    local cur = ""
    local depth = 0
    for i=1,#inside do
        local ch = inside:sub(i,i)
        if ch == "," and depth == 0 then
            table.insert(parts, trim(cur)); cur = ""
        else
            cur = cur .. ch
            if ch == "(" then depth = depth + 1 end
            if ch == ")" then depth = math.max(0, depth - 1) end
        end
    end
    if trim(cur) ~= "" then table.insert(parts, trim(cur)) end
    for i=1,#parts do parts[i] = stripQuotes(parts[i]) end
    return parts
end

local function parseVector3(str)
    if not str or str == "" then return nil end
    local s = trim(str)
    if s:match("^Vector3%.new") then
        local ok, res = pcall(function() local f = loadstring("return " .. s); if not f then error() end; return f() end)
        if ok and typeof(res) == "Vector3" then return res end
    else
        local nums = {}
        for n in s:gmatch("(-?%d+%.?%d*)") do table.insert(nums, tonumber(n)) end
        if #nums >= 3 then return Vector3.new(nums[1], nums[2], nums[3]) end
    end
    return nil
end

local function parseColor3(str)
    if not str or str == "" then return nil end
    local s = trim(str)
    if s:match("^Color3%.fromRGB") then
        local ok, res = pcall(function() local f = loadstring("return " .. s); if not f then error() end; return f() end)
        if ok and typeof(res) == "Color3" then return res end
    else
        local nums = {}
        for n in s:gmatch("(%d+)") do table.insert(nums, tonumber(n)) end
        if #nums >= 3 then return Color3.fromRGB(nums[1], nums[2], nums[3]) end
    end
    return nil
end

local function meshTypeFromString(s)
    if not s then return nil end
    local t = s:lower()
    if t == "block" or t == "brick" then return Enum.MeshType.Brick end
    if t == "sphere" then return Enum.MeshType.Sphere end
    if t == "cylinder" then return Enum.MeshType.Cylinder end
    if t == "head" then return Enum.MeshType.Head end
    if t == "file" then return Enum.MeshType.FileMesh end
    return nil
end

local function resolveLocate(str)
    if not str or str == "" then return nil, "empty" end
    local s = trim(str)
    -- try eval
    local ok, val = pcall(function()
        local f,e = loadstring("return " .. s)
        if not f then error(e) end
        return f()
    end)
    if ok and val then return val end
    -- workspace search
    local found = workspace:FindFirstChild(s, true)
    if found then return found end
    for _, srv in ipairs(game:GetChildren()) do
        if srv and srv.FindFirstChild then
            local f = srv:FindFirstChild(s, true)
            if f then return f end
        end
    end
    return nil, "resolve_failed"
end

-- ===== SeeChat =====
local chatMonitor = {enabled=false, conns={}} 
local function playerChatConnect(pl)
    if not pl or chatMonitor.conns[pl] then return end
    local ok, con = pcall(function() return pl.Chatted:Connect(function(msg) appendChat(false, ("[%s]: %s"):format(pl.Name, tostring(msg)), {180,180,180}) end) end)
    if ok and con then chatMonitor.conns[pl] = con end
end
local function startSeeChat()
    if chatMonitor.enabled then appendSystem("SeeChat already running."); return end
    chatMonitor.enabled = true
    for _,p in ipairs(Players:GetPlayers()) do playerChatConnect(p) end
    chatMonitor.playerAddedConn = Players.PlayerAdded:Connect(function(pl) playerChatConnect(pl) end)
    chatMonitor.playerRemovingConn = Players.PlayerRemoving:Connect(function(pl) if chatMonitor.conns[pl] then pcall(function() chatMonitor.conns[pl]:Disconnect() end); chatMonitor.conns[pl]=nil end end)
    appendSystem("SeeChat started.")
end
local function stopSeeChat()
    if not chatMonitor.enabled then appendSystem("SeeChat not running."); return end
    for pl,con in pairs(chatMonitor.conns) do pcall(function() con:Disconnect() end) end
    chatMonitor.conns = {}
    if chatMonitor.playerAddedConn then pcall(function() chatMonitor.playerAddedConn:Disconnect() end); chatMonitor.playerAddedConn = nil end
    if chatMonitor.playerRemovingConn then pcall(function() chatMonitor.playerRemovingConn:Disconnect() end); chatMonitor.playerRemovingConn = nil end
    chatMonitor.enabled = false
    appendSystem("SeeChat stopped.")
end

-- ===== View (camera) =====
local viewState = {active=false, conn=nil, prevType=nil, prevSubject=nil}
local function startView(pl)
    if not pl or not pl.Character then appendSystem("Player not found to view."); return end
    local hrp = pl.Character:FindFirstChild("HumanoidRootPart") or pl.Character.PrimaryPart
    if not hrp then appendSystem("Target has no HumanoidRootPart/PrimaryPart."); return end
    local cam = Workspace.CurrentCamera
    if viewState.active then appendSystem("Already viewing someone. Use /StopView"); return end
    viewState.prevType = cam.CameraType
    viewState.prevSubject = cam.CameraSubject
    viewState.active = true
    viewState.conn = RunService.RenderStepped:Connect(function()
        if not viewState.active then return end
        if hrp and hrp.Parent then
            cam.CameraType = Enum.CameraType.Scriptable
            cam.CFrame = hrp.CFrame * CFrame.new(0,2,6) * CFrame.Angles(-0.2, math.rad(180), 0)
        else
            if viewState.conn then viewState.conn:Disconnect(); viewState.conn = nil end
            viewState.active = false
        end
    end)
    appendSystem(("Now viewing %s"):format(pl.Name))
end
local function stopView()
    if not viewState.active then appendSystem("Not viewing anyone."); return end
    if viewState.conn then pcall(function() viewState.conn:Disconnect() end); viewState.conn = nil end
    local cam = Workspace.CurrentCamera
    pcall(function()
        cam.CameraType = viewState.prevType or Enum.CameraType.Custom
        cam.CameraSubject = viewState.prevSubject or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid"))
    end)
    viewState.active = false
    appendSystem("Camera restored.")
end

-- ===== OpenAI call (client) =====
local function callOpenAI(prompt, key, proj)
    if not key or key == "" then return nil, "no_key" end
    if not isHttpEnabled() then return nil, "http_disabled" end
    local payload = { model = STATE.MODEL, messages = { { role = "user", content = prompt } }, max_tokens = 350, temperature = 0.7 }
    local headers = { ["Content-Type"] = "application/json", ["Authorization"] = "Bearer "..tostring(key) }
    if proj and proj ~= "" then headers["OpenAI-Project"] = tostring(proj) end
    local ok, resp = pcall(function()
        return HttpService:RequestAsync({
            Url = "https://api.openai.com/v1/chat/completions",
            Method = "POST",
            Headers = headers,
            Body = HttpService:JSONEncode(payload),
            Timeout = 20,
        })
    end)
    if not ok then return nil, tostring(resp) end
    if not resp or not resp.Success then
        local msg = ""
        pcall(function() local j = HttpService:JSONDecode(resp.Body or "{}"); if j and j.error and j.error.message then msg = j.error.message end end)
        return nil, ("http_error_%s: %s"):format(tostring(resp.StatusCode), tostring(msg))
    end
    local ok2, decoded = pcall(function() return HttpService:JSONDecode(resp.Body or "{}") end)
    if not ok2 or not decoded then return nil, "json_decode_failed" end
    local content = decoded and decoded.choices and decoded.choices[1] and decoded.choices[1].message and decoded.choices[1].message.content
    if content then return tostring(content), nil end
    return nil, "no_content"
end

-- ===== Command handler =====
local savedKeeps = {}
local deathCounts = {}

local function handleCommand(raw)
    if not raw or raw:sub(1,1) ~= "/" then return false end
    local cmd = raw:match("^/(%S+)")
    if not cmd then return true end
    local cmdU = cmd:upper()
    local args = parseParenArgs(raw)

    if cmdU == "API" then
        local k = stripQuotes(args[1] or raw:match('%("?(sk%S+)') or "")
        if k == "" then appendSystem('Usage: /API ("sk-...")') else
            STATE.OPENAI_KEY = k; STATE.validated = false
            appendSystem(("API set: %s"):format(redactKey(k)))
        end
        return true
    end

    if cmdU == "APIJ" then
        local p = stripQuotes(args[1] or "")
        if p == "" then appendSystem('Usage: /APIJ ("proj_...")') else STATE.PROJECT_ID = p; appendSystem(("Project set: %s"):format(tostring(p))) end
        return true
    end

    if cmdU == "HELP" then
        appendSystem("/API (\"sk-...\") — set API key")
        appendSystem("/APIJ (\"proj_...\") — set Project ID")
        appendSystem("/SeeChat — start monitoring player chat")
        appendSystem("/UnSeeChat — stop monitoring chat")
        appendSystem('/Instance ("locate"),("Vector3.new(X,Y,Z)"),("Name") — create part')
        appendSystem('/Resize ("locate"),("Vector3.new(X,Y,Z)") — resize part')
        appendSystem('/Position ("locate"),("Vector3.new(X,Y,Z)") — move part')
        appendSystem('/Color ("locate"),("Color3.fromRGB(R,G,B)") — change color')
        appendSystem('/InstanceMesh ("locate"),("Block|Sphere|Cylinder|Head|File") — add mesh')
        appendSystem('/InstanceSurfaceGui ("locate"),("rbxassetid://...") — add surface gui image')
        appendSystem('/View ("PlayerName") — camera view player (uses HumanoidRootPart)')
        appendSystem('/StopView — restore camera')
        appendSystem('/ClearTexts — clear chat window')
        appendSystem('/CheckPlaHP ("Player") — show HP')
        appendSystem('/CheckPlaAround — players within 50 studs')
        appendSystem('/Keep ("text") — save note')
        appendSystem('/HttpService — show HttpService status')
        appendSystem('/HttpEnabled true/false — set HttpService.HttpEnabled (may be restricted)')
        appendSystem('/loadstring ("url") — fetch & run code (DANGEROUS)')
        return true
    end

    if cmdU == "SEECHAT" then startSeeChat(); return true end
    if cmdU == "UNSEECHAT" or cmdU == "UNSEE" then stopSeeChat(); return true end
    if cmdU == "CLEARTEXTS" then
        for _,c in ipairs(gptChat:GetChildren()) do pcall(function() if c.Name:match("^ChatItem_") then c:Destroy() end end) end
        appendSystem("Chat cleared.")
        return true
    end

    if cmdU == "CHECKPLAHP" then
        local name = stripQuotes(args[1] or raw:match("%((.*)%)") or "")
        if name == "" then appendSystem('Usage: /CheckPlaHP ("Player")'); return true end
        local pl = Players:FindFirstChild(name) or (function() for _,p in ipairs(Players:GetPlayers()) do if p.Name:lower():find(name:lower()) then return p end end end)()
        if not pl or not pl.Character then appendSystem("Player not found or no character."); return true end
        local hum = pl.Character:FindFirstChildOfClass("Humanoid")
        if not hum then appendSystem("No Humanoid."); return true end
        appendSystem(("%s HP: %.2f / %.2f"):format(pl.Name, hum.Health, hum.MaxHealth)); return true
    end

    if cmdU == "CHECKPLAAROUND" then
        local radius = 50
        local char = LocalPlayer.Character
        local rootPart = char and (char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart)
        if not rootPart then appendSystem("No character HRP."); return true end
        local nearby = {}
        for _,p in ipairs(Players:GetPlayers()) do
            if p ~= LocalPlayer and p.Character then
                local rp = p.Character:FindFirstChild("HumanoidRootPart") or p.Character.PrimaryPart
                if rp then
                    local d = (rp.Position - rootPart.Position).Magnitude
                    if d <= radius then table.insert(nearby, {p=d}) end
                end
            end
        end
        if #nearby == 0 then appendSystem("No players within 50 studs.") else appendSystem(#nearby.." players within 50 studs.") end
        return true
    end

    if cmdU == "VIEW" then
        local name = stripQuotes(args[1] or "")
        if name == "" then appendSystem('Usage: /View ("Player")'); return true end
        local pl = Players:FindFirstChild(name) or (function() for _,p in ipairs(Players:GetPlayers()) do if p.Name:lower():find(name:lower()) then return p end end end)()
        if not pl then appendSystem("Player not found"); return true end
        startView(pl); return true
    end
    if cmdU == "STOPVIEW" then stopView(); return true end

    if cmdU == "INSTANCE" then
        local locateStr = args[1] or ""
        local vecStr = args[2] or ""
        local nameStr = args[3] or "Instance"
        local parent, err = resolveLocate(locateStr)
        if not parent then appendError(("Locate failed: %s"):format(tostring(err))); return true end
        local size = parseVector3(vecStr) or Vector3.new(1,1,1)
        local ok, part = pcall(function()
            local p = Instance.new("Part")
            p.Name = tostring(nameStr or "Instance")
            p.Size = size
            p.Anchored = false
            p.Parent = parent
            return p
        end)
        if ok then appendSystem(("Created part '%s' in %s"):format(part.Name, tostring(parent))) else appendError(("Create failed: %s"):format(tostring(part))) end
        return true
    end

    if cmdU == "RESIZE" then
        local locateStr = args[1] or ""
        local vecStr = args[2] or ""
        local obj, err = resolveLocate(locateStr)
        if not obj then appendError(("Locate failed: %s"):format(tostring(err))); return true end
        local v = parseVector3(vecStr)
        if not v then appendError("Vector3 parse failed"); return true end
        pcall(function() if obj:IsA("BasePart") then obj.Size = v end if obj.Size then obj.Size = v end end)
        appendSystem(("Resized %s to %s"):format(tostring(obj), tostring(v)))
        return true
    end

    if cmdU == "POSITION" then
        local locateStr = args[1] or ""
        local vecStr = args[2] or ""
        local obj, err = resolveLocate(locateStr)
        if not obj then appendError(("Locate failed: %s"):format(tostring(err))); return true end
        local v = parseVector3(vecStr)
        if not v then appendError("Vector3 parse failed"); return true end
        pcall(function()
            if obj:IsA("BasePart") then obj.CFrame = CFrame.new(v) end
            if obj.Position then obj.Position = v end
        end)
        appendSystem(("Moved %s to %s"):format(tostring(obj), tostring(v)))
        return true
    end

    if cmdU == "COLOR" then
        local locateStr = args[1] or ""
        local colStr = args[2] or ""
        local obj, err = resolveLocate(locateStr)
        if not obj then appendError(("Locate failed: %s"):format(tostring(err))); return true end
        local col = parseColor3(colStr)
        if not col then appendError("Color parse failed"); return true end
        local ok, e = pcall(function() 
            if obj:IsA("BasePart") then obj.Color = col end
            for _,d in ipairs(obj:GetDescendants()) do
                if d:IsA("GuiObject") and d.BackgroundColor3 then pcall(function() d.BackgroundColor3 = col end) end
                if (d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox")) then pcall(function() d.TextColor3 = col end) end
                if (d:IsA("ImageLabel") or d:IsA("ImageButton")) then pcall(function() d.ImageColor3 = col end) end
            end
        end)
        if ok then appendSystem("Color applied.") else appendError(("Color apply failed: %s"):format(tostring(e))) end
        return true
    end

    if cmdU == "INSTANCEMESH" then
        local locateStr = args[1] or ""
        local typeStr = args[2] or ""
        local obj, err = resolveLocate(locateStr)
        if not obj then appendError(("Locate failed: %s"):format(tostring(err))); return true end
        local mtype = meshTypeFromString(typeStr)
        if not mtype then appendError("Unknown mesh type"); return true end
        local ok, mesh = pcall(function()
            local sm = Instance.new("SpecialMesh")
            sm.MeshType = mtype
            sm.Parent = obj
            return sm
        end)
        if ok then appendSystem("Mesh created.") else appendError(("Mesh creation failed: %s"):format(tostring(mesh))) end
        return true
    end

    if cmdU == "INSTANCESURFACEGUI" then
        local locateStr = args[1] or ""
        local asset = args[2] or ""
        local obj, err = resolveLocate(locateStr)
        if not obj then appendError(("Locate failed: %s"):format(tostring(err))); return true end
        local ok, s = pcall(function()
            local sgui = Instance.new("SurfaceGui")
            sgui.Face = Enum.NormalId.Front
            sgui.Parent = obj
            local img = Instance.new("ImageLabel")
            img.Size = UDim2.new(1,0,1,0)
            img.Position = UDim2.new(0,0,0,0)
            img.BackgroundTransparency = 1
            img.Image = tostring(asset or "")
            img.Parent = sgui
            return sgui
        end)
        if ok then appendSystem("SurfaceGui added.") else appendError(("SurfaceGui failed: %s"):format(tostring(s))) end
        return true
    end

    if cmdU == "KEEP" then
        local text = args[1] or raw:match("%((.*)%)") or ""
        text = stripQuotes(text)
        if text == "" then appendSystem('Usage: /Keep ("text")') else
            table.insert(savedKeeps, text)
            appendSystem("Saved note.")
        end
        return true
    end

    if cmdU == "HTTPSERVICE" then
        appendSystem(("HttpService.HttpEnabled = %s"):format(tostring(isHttpEnabled())))
        return true
    end

    if cmdU == "HTTPENABLED" then
        local val = tostring(args[1] or raw:match("%s+(%w+)") or ""):lower()
        if val == "true" then
            pcall(function() HttpService.HttpEnabled = true end); appendSystem("Tried to set HttpEnabled = true")
        elseif val == "false" then
            pcall(function() HttpService.HttpEnabled = false end); appendSystem("Tried to set HttpEnabled = false")
        else
            appendSystem('Usage: /HttpEnabled true|false')
        end
        return true
    end

    if cmdU == "LOADSTRING" then
        local url = stripQuotes(args[1] or raw:match("%((.*)%)") or "")
        if url == "" then appendSystem('Usage: /loadstring ("https://...")'); return true end
        appendSystem("Fetching script...")
        task.spawn(function()
            local ok, res = pcall(function() return HttpService:RequestAsync({Url = url, Method = "GET", Timeout = 20}) end)
            if not ok or not res or not res.Success then appendError("Fetch failed"); return end
            local code = res.Body or ""
            local f, e = loadstring(code)
            if not f then appendError("Loadstring compile error: "..tostring(e)); return end
            local ok2, ret = pcall(f)
            if not ok2 then appendError("Loadstring runtime error: "..tostring(ret)); return end
            appendSystem("Loaded remote script.")
        end)
        return true
    end

    appendSystem(("Unknown command: /%s (use /Help)"):format(cmd))
    return true
end

-- ===== Bind top-row buttons =====
if projBtn then
    projBtn.MouseButton1Click:Connect(function()
        local v = trim(projBox.Text or "")
        if v == "" then appendSystem("Project ID empty."); return end
        if not tostring(v):match("^proj_") then appendSystem("Project ID looks invalid (should start with proj_)"); return end
        STATE.PROJECT_ID = v
        projFrame.Visible = false
        apiFrame.Visible = true
        appendSystem("Project saved. Enter API key next.")
    end)
    projBox.FocusLost:Connect(function(enter) if enter then projBtn:CaptureFocus(); projBtn:MouseButton1Click() end end)
end
if apiBtn then
    apiBtn.MouseButton1Click:Connect(function()
        local raw = trim(apiBox.Text or "")
        if raw == "" then appendSystem("API key empty."); return end
        appendSystem("Validating API key...")
        task.spawn(function()
            local ok, err = pcall(function() local r,e = callOpenAI("Hello", raw, STATE.PROJECT_ID); return r,e end)
            if ok then
                STATE.OPENAI_KEY = raw; STATE.validated = true
                appendSystem(("✅ API saved: %s"):format(redactKey(raw)))
            else
                appendError(("Validation error: %s"):format(tostring(err)))
            end
        end)
    end)
    apiBox.FocusLost:Connect(function(enter) if enter then apiBtn:CaptureFocus(); apiBtn:MouseButton1Click() end end)
end

-- ===== sendChat (safe) =====
local function sendChat()
    local text = tostring(chatBox and chatBox.Text or "")
    if text:match("^%s*$") then return end

    if text:sub(1,1) == "/" then
        local ok, res = pcall(handleCommand, text)
        if not ok then
            warn("[ChatGPT-diag] handleCommand error:", res)
            appendError and appendError("Command error: "..tostring(res))
        end
        chatBox.Text = ""
        return
    end

    if type(appendChat) ~= "function" and not ( _G and type(_G.ChatGPT_appendChat) == "function") then
        warn("[ChatGPT-diag] appendChat is nil — cannot show user message")
        print("[ChatGPT-user]", text)
        chatBox.Text = ""
        return
    end

    if not STATE.OPENAI_KEY or not STATE.validated then
        appendError("Error HttpService: Did you forget to put API?")
        chatBox.Text = ""
        return
    end

    local userMsg = trim(text)
    if type(_G.ChatGPT_appendChat) == "function" then _G.ChatGPT_appendChat(true, userMsg, {86,170,255}) else appendChat(true, userMsg, {86,170,255}) end
    chatBox.Text = ""
    STATE.requestInFlight = true
    if type(_G.ChatGPT_appendChat) == "function" then _G.ChatGPT_appendChat(false, "[System] ⌛ Thinking...", {255,255,255}) else appendChat(false, "[System] ⌛ Thinking...", {255,255,255}) end

    task.spawn(function()
        if not STATE.OPENAI_KEY then
            appendError("Error HttpService: Did you forget to put API?")
            STATE.requestInFlight = false
            return
        end
        local reply, err = callOpenAI and callOpenAI(userMsg, STATE.OPENAI_KEY, STATE.PROJECT_ID) or nil, "callOpenAI missing"
        STATE.requestInFlight = false
        if reply then
            if type(_G.ChatGPT_appendChat) == "function" then _G.ChatGPT_appendChat(false, reply, {255,255,255}) else appendChat(false, reply, {255,255,255}) end
        else
            appendError(("Error: %s"):format(tostring(err or "unknown")))
        end
    end)
end

sendBtn.MouseButton1Click:Connect(sendChat)
chatBox.FocusLost:Connect(function(enter) if enter then sendChat() end end)

-- ===== toggle panel =====
local openState = false
local function togglePanel()
    openState = not openState
    if openState then safeTween(panel, { Position = UDim2.new(0,0,0.05,0) }, 0.28) else safeTween(panel, { Position = UDim2.new(-0.4,0,0.05,0) }, 0.28) end
end

if toggleButton then
    pcall(function() toggleButton.MouseButton1Click:Connect(togglePanel) end)
else
    local fallback = rootGui:FindFirstChild("ChatGPT_Toggle_Fallback")
    if not fallback then
        fallback = Instance.new("TextButton")
        fallback.Name = "ChatGPT_Toggle_Fallback"
        fallback.Size = UDim2.new(0,40,0,22)
        fallback.Position = UDim2.new(0,4,0,4)
        fallback.Text = "GPT"
        fallback.Parent = rootGui
    end
    pcall(function() fallback.MouseButton1Click:Connect(togglePanel) end)
end

appendSystem("ChatGPT UI ready — type /Help for commands")

-- expose a few globals for console debugging
_G.ChatGPT_State = STATE
_G.ChatGPT_appendChat = appendChat
_G.ChatGPT_callOpenAI = callOpenAI
